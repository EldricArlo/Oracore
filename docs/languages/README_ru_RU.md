<div align="center">
  <img src="./src/media/icon-256.png" alt="Oracipher Icon" width="128">
  <h1 style="border-bottom: none;">Oracipher Core</h1>

# Библиотека ядра гибридного шифрования с высоким уровнем безопасности

| Build & Test | License | Language | Dependencies |
| :---: | :---: | :---: | :---: |
| ![Build Status](https://img.shields.io/badge/tests-passing-brightgreen) | ![License](https://img.shields.io/badge/license-Dual--Licensed-blue) | ![Language](https://img.shields.io/badge/language-C11-purple) | ![Libsodium](https://img.shields.io/badge/libsodium-v1.0.18+-brightgreen) ![OpenSSL](https://img.shields.io/badge/OpenSSL-v3.0+-0075A8) ![Libcurl](https://img.shields.io/badge/libcurl-v7.68+-E5522D) |

</div>

---

### **Содержание**
1.  [Видение проекта и основные принципы](#1-видение-проекта-и-основные-принципы)
2.  [Основные возможности](#2-основные-возможности)
3.  [Структура проекта](#3-структура-проекта)
4.  [Быстрый старт](#4-быстрый-старт)
    *   [4.1 Зависимости](#41-зависимости)
    *   [4.2 Компиляция и тестирование](#42-компиляция-и-тестирование)
5.  [Руководство по использованию](#5-руководство-по-использованию)
    *   [5.1 Использование в качестве утилиты командной строки (`hsc_cli` и `test_ca_util`)](#51-использование-в-качестве-утилиты-командной-строки-hsc_cli--test_ca_util)
    *   [5.2 Использование в качестве библиотеки в вашем проекте](#52-использование-в-качестве-библиотеки-в-вашем-проекте)
6.  [Глубокое погружение: Техническая архитектура](#6-глубокое-погружение-техническая-архитектура)
7.  [Расширенная настройка: Повышение безопасности с помощью переменных окружения](#7-расширенная-настройка-повышение-безопасности-с-помощью-переменных-окружения)
8.  [Продвинутая тема: Сравнение режимов шифрования](#8-продвинутая-тема-сравнение-режимов-шифрования)
9.  [Справочник по основному API (`include/hsc_kernel.h`)](#9-справочник-по-основному-api-includehsc_kernelh)
10. [Вклад в проект](#10-вклад-в-проект)
11. [Примечания к сертификатам](#11-примечания-к-сертификатам)
12. [Лицензия - Модель двойного лицензирования](#12-лицензия---модель-двойного-лицензирования)

---

## 1. Видение проекта и основные принципы

Этот проект представляет собой ориентированную на безопасность, современную библиотеку ядра гибридного шифрования, реализованную на стандарте C11. Его цель — предоставить проверенный в боевых условиях образец, демонстрирующий, как объединить ведущие в отрасли криптографические библиотеки (**libsodium**, **OpenSSL**, **libcurl**) в надежное, отказоустойчивое и простое в использовании решение для сквозного шифрования.

Наша разработка следует этим основным принципам безопасности:

*   **Выбор проверенной, современной криптографии:** Мы никогда не создаем собственные криптографические алгоритмы. Мы используем только современные криптографические примитивы, широко признанные сообществом и устойчивые к атакам по побочным каналам.
*   **Эшелонированная оборона:** Безопасность не зависит от одного уровня защиты. Мы реализуем защиту на нескольких уровнях, включая управление памятью, дизайн API и流程 протокола.
*   **Безопасные настройки по умолчанию и политика «отказа в доступе при сбое» (Fail-Closed):** Поведение системы по умолчанию должно быть безопасным. При возникновении неопределенного состояния (например, невозможности проверить статус отзыва сертификата) система должна выбрать отказ и прекратить операцию (fail-closed), а не продолжать работу.
*   **Минимизация раскрытия конфиденциальных данных:** Мы строго контролируем жизненный цикл, область видимости и время нахождения в памяти критически важных данных, таких как приватные ключи, сводя их к абсолютно необходимому минимуму.

## 2. Основные возможности

*   **Надежная модель гибридного шифрования:**
    *   **Симметричное шифрование:** Предоставляет поточное шифрование AEAD (для больших блоков данных) и одноразовое шифрование AEAD (для малых блоков данных) на основе **XChaCha20-Poly1305**.
    *   **Асимметричное шифрование:** Использует **X25519** (на основе Curve2519) для механизма инкапсуляции ключа (KEM), чтобы обернуть симметричный сессионный ключ, гарантируя, что только предполагаемый получатель сможет его расшифровать.

*   **Стек современных криптографических примитивов:**
    *   **Производство ключей:** Используется **Argon2id**, победитель конкурса хеширования паролей, для эффективного противодействия попыткам взлома с помощью GPU и ASIC.
    *   **Цифровые подписи:** Используется **Ed25519** для обеспечения высокоскоростных и высоконадежных цифровых подписей.
    *   **Унификация ключей:** Умело используется возможность безопасного преобразования ключей Ed25519 в ключи X25519, что позволяет одной паре мастер-ключей удовлетворять потребности как в подписи, так и в шифровании.

*   **Полная поддержка инфраструктуры открытых ключей (PKI):**
    *   **Жизненный цикл сертификата:** Поддержка генерации запросов на подпись сертификата (CSR), соответствующих стандарту X.509 v3.
    *   **Строгая проверка сертификатов:** Предоставляет стандартизированный процесс проверки сертификатов, включая цепочку доверия, срок действия и соответствие субъекта.
    *   **Обязательная проверка отзыва (OCSP):** Встроенная строгая проверка по протоколу OCSP (Online Certificate Status Protocol) с политикой «отказа в доступе при сбое». Если надлежащий статус сертификата не может быть подтвержден, операция немедленно прерывается.

*   **Непробиваемая безопасность памяти:**
    *   Предоставляет доступ к функциям безопасной памяти `libsodium` через публичный API, позволяя клиентам безопасно обрабатывать конфиденциальные данные (например, сессионные ключи).
    *   **[Задокументировано с точки зрения безопасности]** Все внутренние приватные ключи **и другие критически важные секреты (например, сиды ключей, промежуточные хеш-значения)** хранятся в заблокированной памяти, **что предотвращает их выгрузку на диск операционной системой**, и безопасно обнуляются перед освобождением. Границы с сторонними библиотеками (такими как OpenSSL) тщательно контролируются. Когда конфиденциальные данные должны пересекать границы в стандартные области памяти (например, при передаче сида в OpenSSL в `generate_csr`), эта библиотека использует методы эшелонированной обороны (такие как немедленная очистка буферов памяти после использования) для снижения присущих рисков, что представляет собой лучшую практику при взаимодействии с библиотеками, не осведомленными о безопасной памяти.

*   **Высококачественные инженерные практики:**
    *   **Четкие границы API:** Предоставляет единый публичный заголовочный файл `hsc_kernel.h`, который инкапсулирует все детали внутренней реализации с помощью непрозрачных указателей, достигая высокой связности и низкого зацепления.
    *   **Всеобъемлющий набор тестов:** Включает набор модульных и интеграционных тестов, охватывающих основную криптографию, PKI и высокоуровневые функции API для обеспечения корректности и надежности кода.
    *   **Разделенная система логирования:** Реализует механизм логирования на основе колбэков, предоставляя клиентскому приложению полный контроль над тем, как и где отображаются сообщения журнала, что делает библиотеку подходящей для любой среды.
    *   **Исчерпывающая документация и примеры:** Предоставляет подробный `README.md`, а также готовую к запуску демонстрационную программу и мощную утилиту командной строки.

## 3. Структура проекта

Проект использует четкую, многоуровневую структуру каталогов для разделения ответственности.

```.
├── include/
│   └── hsc_kernel.h      # [Ядро] Единственный публичный заголовочный файл API
├── src/                  # Исходный код
│   ├── common/           # Общие внутренние модули (безопасная память, логирование)
│   ├── core_crypto/      # Внутренние модули основной криптографии (обертки libsodium)
│   ├── pki/              # Внутренние модули PKI (обертки OpenSSL, libcurl)
│   ├── hsc_kernel.c      # [Ядро] Реализация публичного API
│   ├── main.c            # Пример использования API: сквозная демонстрационная программа
│   └── cli.c             # Пример использования API: мощная утилита командной строки
├── tests/                # Модульные тесты и утилиты для тестирования
│   ├── test_*.c          # Модульные тесты для различных модулей
│   ├── test_api_integration.c # [Новое] Сквозные тесты для высокоуровневых API
│   ├── test_helpers.h/.c # Вспомогательные функции для тестов (генерация CA, подпись)
│   └── test_ca_util.c    # Исходный код отдельной утилиты для тестового CA
├── Makefile              # Скрипт для сборки и управления задачами
└── README.md             # Документация этого проекта
```

## 4. Быстрый старт

### 4.1 Зависимости

*   **Инструменты сборки:** `make`
*   **Компилятор C:** `gcc` или `clang` (с поддержкой C11 и `-Werror`)
*   **libsodium:** (`libsodium-dev`)
*   **OpenSSL:** Рекомендуется **v3.0** или новее (`libssl-dev`)
*   **libcurl:** (`libcurl4-openssl-dev`)

**Установка на основных системах:**

*   **Debian/Ubuntu:**
    ```bash
    sudo apt-get update
    sudo apt-get install build-essential libsodium-dev libssl-dev libcurl4-openssl-dev
    ```
*   **Fedora/RHEL/CentOS:**
    ```bash
    sudo dnf install gcc make libsodium-devel openssl-devel libcurl-devel
    ```
*   **macOS (с использованием Homebrew):**
    ```bash
    brew install libsodium openssl@3 curl
    ```

### 4.2 Компиляция и тестирование

Проект спроектирован как высокопортируемый и избегает жестко закодированных путей, специфичных для платформы, обеспечивая его корректную сборку и запуск на всех поддерживаемых системах.

1.  **Скомпилировать все цели (библиотеку, демо, CLI, тесты):**
    ```bash
    make all
    ```

2.  **Запустить полный набор тестов (критически важный шаг):**
    ```bash
    make run-tests
    ```
    > **Важное примечание об ожидаемом поведении теста OCSP**
    >
    > Один из тестовых случаев в `test_pki_verification` намеренно проверяет сертификат, указывающий на несуществующий локальный OCSP-сервер (`http://127.0.0.1:8888`). Сетевой запрос завершится неудачей, и в этот момент функция `hsc_verify_user_certificate` **должна** вернуть `-12` (код ошибки для `HSC_ERROR_CERT_REVOKED_OR_OCSP_FAILED`). Тестовая программа утверждает именно это возвращаемое значение.
    >
    > Эта «неудача» является **ожидаемым и правильным поведением**, так как она прекрасно демонстрирует, что наша политика безопасности «отказа в доступе при сбое» реализована корректно: **если статус отзыва сертификата не может быть подтвержден по какой-либо причине, он считается недействительным.**

3.  **Запустить демонстрационную программу:**
    ```bash
    ./bin/hsc_demo
    ```

4.  **Исследовать утилиту командной строки:**
    ```bash
    ./bin/hsc_cli
    ```

5.  **Очистить файлы сборки:**
    ```bash
    make clean
    ```

## 5. Руководство по использованию

### 5.1 Использование в качестве утилиты командной строки (`hsc_cli` и `test_ca_util`)

Этот раздел предоставляет полный, самодостаточный рабочий процесс, демонстрирующий, как два пользователя, Алиса и Боб, могут выполнить безопасный обмен файлами с помощью предоставленных утилит командной строки.

**Роли утилит:**
*   `./bin/test_ca_util`: Вспомогательная утилита, которая имитирует Центр Сертификации (CA), ответственный за генерацию корневого сертификата и подписание сертификатов пользователей.
*   `./bin/hsc_cli`: Основная клиентская утилита для генерации ключей, создания CSR, проверки сертификатов и шифрования/расшифрования файлов.

**Пример полного рабочего процесса: Алиса шифрует файл и безопасно отправляет его Бобу**

1.  **(Настройка) Создать тестовый Центр Сертификации (CA):**
    *Мы используем `test_ca_util` для генерации корневого ключа CA и самоподписанного сертификата.*
    ```bash
    ./bin/test_ca_util gen-ca ca.key ca.pem
    ```

2.  **(Алиса и Боб) Сгенерировать свои пары мастер-ключей:**
    ```bash
    ./bin/hsc_cli gen-keypair alice
    ./bin/hsc_cli gen-keypair bob
    ```
    *Это создаст `alice.key`, `alice.pub`, `bob.key` и `bob.pub`.*

3.  **(Алиса и Боб) Сгенерировать запросы на подпись сертификата (CSR):**
    ```bash
    ./bin/hsc_cli gen-csr alice.key "alice@example.com"
    ./bin/hsc_cli gen-csr bob.key "bob@example.com"
    ```
    *Это создаст `alice.csr` и `bob.csr`.*

4.  **(CA) Подписать CSR для выпуска сертификатов:**
    *CA использует свой приватный ключ (`ca.key`) и сертификат (`ca.pem`) для подписания CSR.*
    ```bash
    ./bin/test_ca_util sign alice.csr ca.key ca.pem alice.pem
    ./bin/test_ca_util sign bob.csr ca.key ca.pem bob.pem
    ```
    *Теперь у Алисы и Боба есть их официальные сертификаты, `alice.pem` и `bob.pem`.*

5.  **(Алиса) Проверяет сертификат Боба перед отправкой:**
    *Алиса использует доверенный сертификат CA (`ca.pem`) для проверки личности Боба. Это критически важный шаг перед тем, как доверять его сертификату.*
    ```bash
    ./bin/hsc_cli verify-cert bob.pem --ca ca.pem --user "bob@example.com"
    ```

6.  **(Алиса) Шифрует файл для Боба:**
    *У Алисы теперь есть несколько вариантов:*

    **Вариант A: На основе сертификата с проверкой (Безопасно по умолчанию и Рекомендуется)**
    > Это стандартный, безопасный способ работы. Утилита **требует**, чтобы Алиса предоставила сертификат CA и ожидаемое имя пользователя для выполнения полной, строгой проверки сертификата Боба перед шифрованием.
    ```bash
    echo "This is top secret information." > secret.txt
    ./bin/hsc_cli encrypt secret.txt --to bob.pem --from alice.key --ca ca.pem --user "bob@example.com"
    ```

    **Вариант B: На основе сертификата без проверки (Опасно - только для экспертов)**
    > Если Алиса абсолютно уверена в подлинности сертификата и хочет пропустить проверку, она должна явно использовать флаг `--no-verify`. **Это не рекомендуется.**
    ```bash
    # Использовать с крайней осторожностью!
    ./bin/hsc_cli encrypt secret.txt --to bob.pem --from alice.key --no-verify
    ```

    **Вариант C: Режим прямого ключа (Продвинутый - для предварительно доверенных ключей)**
    *Если Алиса уже получила публичный ключ Боба (`bob.pub`) по безопасному, доверенному каналу, она может шифровать непосредственно на него, минуя всю логику сертификатов.*
    ```bash
    ./bin/hsc_cli encrypt secret.txt --recipient-pk-file bob.pub --from alice.key
    ```
    *Все варианты создают `secret.txt.hsc`. Теперь Алиса может отправить `secret.txt.hsc` и свой сертификат `alice.pem` Бобу.*

7.  **(Боб) Расшифровывает файл при получении:**
    *Боб использует свой приватный ключ (`bob.key`) для расшифровки файла. В зависимости от того, как Алиса зашифровала его, ему понадобится либо ее сертификат (`alice.pem`), либо ее сырой публичный ключ (`alice.pub`).*

    **Если Алиса использовала вариант A или B (Сертификат):**
    ```bash
    ./bin/hsc_cli decrypt secret.txt.hsc --to bob.key --from alice.pem
    ```

    **Если Алиса использовала вариант C (Прямой ключ):**
    ```bash
    ./bin/hsc_cli decrypt secret.txt.hsc --to bob.key --sender-pk-file alice.pub
    ```
    *Обе команды создадут `secret.txt.decrypted`.*
    ```bash
    cat secret.txt.decrypted
    ```

### 5.2 Использование в качестве библиотеки в вашем проекте

`src/main.c` служит отличным примером интеграции. Типичная последовательность вызовов API выглядит следующим образом:

1.  **Глобальная инициализация и настройка логирования:** Вызовите `hsc_init()` при запуске и зарегистрируйте колбэк для логирования.
    ```c
    #include "hsc_kernel.h"
    #include <stdio.h>

    // Определите простую функцию логирования для вашего приложения
    void my_app_logger(int level, const char* message) {
        // Пример: выводить ошибки в stderr, информацию в stdout
        if (level >= 2) { // 2 = ERROR
            fprintf(stderr, "[HSC_LIB_ERROR] %s\n", message);
        } else {
            printf("[HSC_LIB_INFO] %s\n", message);
        }
    }

    int main() {
        if (hsc_init() != HSC_OK) {
            // Обработка фатальной ошибки
        }
        // Зарегистрируйте вашу функцию логирования в библиотеке
        hsc_set_log_callback(my_app_logger);

        // ... Ваш код ...
        hsc_cleanup();
        return 0;
    }
    ```

2.  **Отправитель (Алиса) шифрует данные:**
    ```c
    // 1. Сгенерировать одноразовый сессионный ключ
    unsigned char session_key[HSC_SESSION_KEY_BYTES];
    hsc_random_bytes(session_key, sizeof(session_key));

    // 2. Зашифровать данные сессионным ключом с помощью AEAD (для небольших данных)
    const char* message = "Secret message";
    // ... (логика шифрования такая же, как в примере) ...

    // 3. Проверить сертификат получателя (Боба)
    if (hsc_verify_user_certificate(bob_cert_pem, ca_pem, "bob@example.com") != HSC_OK) {
        // Сертификат недействителен, прервать! Библиотека запишет детали через ваш колбэк.
    }

    // 4. Извлечь публичный ключ Боба из его сертификата
    unsigned char bob_pk[HSC_MASTER_PUBLIC_KEY_BYTES];
    if (hsc_extract_public_key_from_cert(bob_cert_pem, bob_pk) != HSC_OK) {
        // Обработка ошибки извлечения
    }

    // 5. Инкапсулировать сессионный ключ
    // ... (логика инкапсуляции такая же, как в примере) ...
    ```

3.  **Получатель (Боб) расшифровывает данные:**
    *Логика расшифровки остается прежней, но любые внутренние ошибки во время деинкапсуляции или расшифровки AEAD теперь будут сообщаться через ваш зарегистрированный колбэк `my_app_logger`, а не напрямую засорять `stderr`.*

## 6. Глубокое погружение: Техническая архитектура

В основе этого проекта лежит модель гибридного шифрования, которая сочетает в себе преимущества асимметричной и симметричной криптографии для достижения как безопасной, так и эффективной передачи данных.

**Схема потока данных и отношений ключей:**

```
ОТПРАВИТЕЛЬ (АЛИСА)                                      ПОЛУЧАТЕЛЬ (БОБ)
========================================================================
        [ Открытый текст ] --> Генерация [ Сессионный ключ ]
                            |           |
(Симметричное шифрование) <-'           '-> (Асимметричная инкапсуляция) исп.: Публичный ключ Боба, Приватный ключ Алисы
        |                                             |
[ Зашифрованные данные ]                 [ Инкапсулированный сессионный ключ ]
        |                                             |
        '---------------------.   .-------------------'
                              |   |
                              v   v
                          [ Пакет данных ]
                              |
     ==================>  По сети/файлу  =================>
                              |
                          [ Пакет данных ]
                              |   |
              .---------------'   '-----------------.
              |                                     |
[ Инкапсулированный сессионный ключ ]    [ Зашифрованные данные ]
              |                                     |
              v                                     |
(Асимметричная деинкапсуляция) исп.: Приватный ключ Боба, Публичный ключ Алисы
              |                                     |
              v                                     |
         [ Восстановленный сессионный ключ ] <-$----' (Симметричное расшифрование)
              |
              v
         [ Открытый текст ]
```

## 7. Расширенная настройка: Повышение безопасности с помощью переменных окружения

Для адаптации к будущим требованиям к оборудованию и безопасности без изменения кода, этот проект поддерживает **увеличение** вычислительной стоимости функции производства ключей (Argon2id) через переменные окружения.

*   **`HSC_ARGON2_OPSLIMIT`**: Устанавливает количество операций (вычислительных раундов) для Argon2id.
*   **`HSC_ARGON2_MEMLIMIT`**: Устанавливает использование памяти в байтах для Argon2id.

**Важное примечание по безопасности:** Эта функция может **использоваться только для усиления параметров безопасности**. Если значения, установленные в переменных окружения, ниже минимальных базовых уровней безопасности, встроенных в проект, программа автоматически проигнорирует небезопасные значения и применит встроенные минимумы.

**Пример использования:**

```bash
# Пример: увеличить лимит операций до 10 и лимит памяти до 512 МБ.
# Примечание: HSC_ARGON2_MEMLIMIT требует значение в байтах.
# 512 * 1024 * 1024 = 536870912 байт.
export HSC_ARGON2_OPSLIMIT=10
export HSC_ARGON2_MEMLIMIT=536870912

# Любая программа, запущенная в оболочке с этими переменными, автоматически будет использовать эти более сильные параметры.
./bin/hsc_cli gen-keypair my_strong_key```

## 8. Продвинутая тема: Сравнение режимов шифрования

Oracipher Core предоставляет два различных рабочих процесса гибридного шифрования, каждый с разными гарантиями безопасности. Выбор правильного является критически важным.

### Рабочий процесс на основе сертификатов (по умолчанию и рекомендуется)

*   **Как это работает:** Использует сертификаты X.509 для привязки личности пользователя (например, `bob@example.com`) к его публичному ключу.
*   **Гарантии безопасности:**
    *   **Аутентификация:** Криптографически проверяет, что публичный ключ действительно принадлежит предполагаемому получателю.
    *   **Целостность:** Гарантирует, что сертификат не был подделан.
    *   **Проверка отзыва:** Активно проверяет через OCSP, был ли сертификат отозван издавшим его центром.
*   **Когда использовать:** В любом сценарии, где у отправителя и получателя нет предварительно существующего, высокозащищенного канала для обмена публичными ключами. Это стандарт для большинства коммуникаций в Интернете.

### Рабочий процесс с прямым ключом (сырым) (продвинутый)

*   **Как это работает:** Обходит всю логику PKI и сертификатов, шифруя непосредственно на файл сырого публичного ключа.
*   **Гарантии безопасности:**
    *   Обеспечивает тот же уровень **конфиденциальности** и **целостности** для самих зашифрованных данных, что и режим с сертификатами.
*   **Компромиссы в безопасности:**
    *   **Нет аутентификации:** Этот режим **не** проверяет личность владельца ключа. Пользователь несет полную ответственность за обеспечение подлинности используемого им публичного ключа. Использование неверного или вредоносного публичного ключа приведет к шифрованию данных для неверной стороны.
*   **Когда использовать:** Только в закрытых системах или специфических протоколах, где публичные ключи были обменены и проверены через независимый, доверенный внеполосный механизм (например, ключи встроены в прошивку безопасного устройства или проверены лично).

## 9. Справочник по основному API (`include/hsc_kernel.h`)

### Инициализация и очистка
| Функция | Описание |
| :--- | :--- |
| `int hsc_init()` | **(Должна быть вызвана первой)** Инициализирует всю библиотеку. |
| `void hsc_cleanup()` | Вызывать перед выходом из программы для освобождения глобальных ресурсов. |

### Управление ключами
| Функция | Описание |
| :--- | :--- |
| `hsc_master_key_pair* hsc_generate_master_key_pair()` | Генерирует новую пару мастер-ключей. |
| `hsc_master_key_pair* hsc_load_master_key_pair_from_private_key(...)` | Загружает приватный ключ из файла. |
| `int hsc_save_master_key_pair(...)` | Сохраняет пару ключей в файлы. |
| `void hsc_free_master_key_pair(hsc_master_key_pair** kp)` | Безопасно освобождает пару мастер-ключей. |
| `int hsc_get_master_public_key(const hsc_master_key_pair* kp, ...)` | **[Новое]** Извлекает сырой публичный ключ из дескриптора пары ключей. |

### PKI и сертификаты
| Функция | Описание |
| :--- | :--- |
| `int hsc_generate_csr(...)` | Генерирует запрос на подпись сертификата (CSR) в формате PEM. |
| `int hsc_verify_user_certificate(...)` | **(Ядро)** Выполняет полную проверку сертификата (цепочка, срок действия, субъект, OCSP). |
| `int hsc_extract_public_key_from_cert(...)` | Извлекает публичный ключ из проверенного сертификата. |

### Инкапсуляция ключа (асимметричная)
| Функция | Описание |
| :--- | :--- |
| `int hsc_encapsulate_session_key(...)` | Шифрует сессионный ключ с использованием публичного ключа получателя. |
| `int hsc_decapsulate_session_key(...)` | Расшифровывает сессионный ключ с использованием приватного ключа получателя. |

### Поточное шифрование (симметричное, для больших файлов)
| Функция | Описание |
| :--- | :--- |
| `hsc_crypto_stream_state* hsc_crypto_stream_state_new_push(...)` | Создает объект состояния потока шифрования. |
| `hsc_crypto_stream_state* hsc_crypto_stream_state_new_pull(...)` | Создает объект состояния потока расшифрования. |
| `int hsc_crypto_stream_push(...)` | Шифрует порцию данных в потоке. |
| `int hsc_crypto_stream_pull(...)` | Расшифровывает порцию данных в потоке. |
| `void hsc_crypto_stream_state_free(hsc_crypto_stream_state** state)` | Освобождает объект состояния потока. |
| `int hsc_hybrid_encrypt_stream_raw(...)` | Выполняет полное гибридное шифрование файла с использованием сырого публичного ключа. |
| `int hsc_hybrid_decrypt_stream_raw(...)` | Выполняет полное гибридное расшифрование файла с использованием сырого публичного ключа. |

### Шифрование данных (симметричное, для небольших данных)
| Функция | Описание |
| :--- | :--- |
| `int hsc_aead_encrypt(...)` | Выполняет аутентифицированное шифрование **небольшого фрагмента данных** с использованием AEAD. |
| `int hsc_aead_decrypt(...)` | Расшифровывает и проверяет данные, зашифрованные `hsc_aead_encrypt`. |

### Безопасная память
| Функция | Описание |
| :--- | :--- |
| `void* hsc_secure_alloc(size_t size)` | Выделяет защищенный, не выгружаемый блок памяти. |
| `void hsc_secure_free(void* ptr)` | Безопасно обнуляет и освобождает защищенный блок памяти. |

### Логирование
| Функция | Описание |
| :--- | :--- |
| `void hsc_set_log_callback(hsc_log_callback callback)` | **[Новое]** Регистрирует функцию обратного вызова для обработки всех внутренних журналов библиотеки. |

## 10. Вклад в проект

Мы приветствуем любые формы вклада! Если вы нашли ошибку, у вас есть предложение по новой функции или вы хотите улучшить документацию, не стесняйтесь отправлять Pull Request или создавать Issue.

## 11. Примечания к сертификатам

Этот проект использует систему сертификатов **X.509 v3** для привязки публичных ключей к идентификаторам пользователей (например, `alice@example.com`), тем самым устанавливая доверие. Процесс проверки сертификата включает **проверку цепочки подписей**, **проверку срока действия**, **проверку личности субъекта** и **проверку статуса отзыва (OCSP)**, все это в рамках строгой политики «отказа в доступе при сбое».

## 12. Лицензия - Модель двойного лицензирования

Этот проект распространяется по **двойной лицензии**:

### 1. GNU Affero General Public License v3.0 (AGPLv3)
Эта лицензия подходит для проектов с открытым исходным кодом, академических исследований и личного изучения. Она требует, чтобы любые производные работы, будь то измененные или предлагаемые как услуга по сети, также имели свой полный исходный код, доступный под лицензией AGPLv3.

### 2. Коммерческая лицензия
Коммерческая лицензия должна быть получена для любых коммерческих приложений, продуктов или услуг с закрытым исходным кодом. Если вы не хотите быть связанными условиями открытого исходного кода AGPLv3, вы должны приобрести коммерческую лицензию.

**Для получения коммерческой лицензии, пожалуйста, свяжитесь с: `eldric520lol@gmail.com`**