你好，从现在开始，你将执行一个分为两个连续阶段的、高度结构化的任务。你首先作为一名顶尖的软件架构师生成一个复杂的C语言加密项目，然后立即转变为一个专家审查委员会，对你刚刚生成的代码进行深度审查。

### **第一阶段：【创世纪】首席架构师模式 - 生成 "Oracipher Core"**

**你的角色:** 顶级的安全软件架构师和C语言开发专家。
**你的任务:** 设计并完整实现一个名为 "Oracipher Core" 的高安全性混合加密内核库。输出必须是生产级别的完整代码文件。

---

#### **1. 核心设计原则 (Core Principles)**

你的设计必须严格遵守以下四个核心安全原则：

1.  **绝不自研加密算法 (Vetted, Modern Cryptography):** 只能使用经过全球密码学界广泛审查、公认的现代密码学原语。所有实现都必须基于专业的、抗侧信道攻击的库（如 libsodium）。
2.  **深度防御 (Defense-in-Depth):** 安全性不能依赖于任何单一环节。你需要在API设计、内存管理、协议流程、错误处理等多个层面构建保护。
3.  **安全默认与“故障关闭” (Secure Defaults & "Fail-Closed"):** 系统的默认行为必须是安全的。当遇到不确定状态时（例如，无法验证证书吊销状态），系统必须选择失败并终止操作（"Fail-Closed"），而不是冒险继续。
4.  **最小化敏感数据暴露 (Minimize Sensitive Data Exposure):** 严格控制私钥等关键数据在内存中的生命周期、作用域和停留时间，用后立即安全擦除。

#### **2. 技术栈与架构 (Tech Stack & Architecture)**

*   **语言:** C11 标准。
*   **核心依赖库:**
    *   **Libsodium:** 用于核心的对称/非对称加密、密钥派生和签名。
    *   **OpenSSL (v3.0+):** 专门用于处理PKI体系，如X.509证书的解析、验证和CSR生成。
    *   **Libcurl:** 用于执行网络请求，特别是OCSP检查。
*   **架构:**
    1.  **公共API层 (`hsc_kernel.h/.c`):** 这是唯一的对外的接口。使用**不透明指针 (Opaque Pointers)** 隐藏所有内部数据结构和实现细节，实现高内聚、低耦合。
    2.  **内部核心模块层 (`src/`):**
        *   **核心加密模块 (`core_crypto/`):** Libsodium的封装层。负责密钥对管理、密钥派生、AEAD加解密和密钥封装/解封装。
        *   **PKI处理模块 (`pki/`):** OpenSSL和Libcurl的封装层。负责CSR生成、证书解析、公钥提取以及最关键的**证书链验证**和**OCSP吊销检查**。
        *   **通用模块 (`common/`):** 包含安全内存管理等被多处使用的通用功能。
    3.  **应用层 (Examples):** 提供一个命令行工具 (`cli.c`) 和一个演示程序 (`main.c`)，展示如何正确使用公共API。

#### **3. 功能模块详细规格 (Module Specifications)**

##### **3.1. 公共API (`hsc_kernel.h`)**

*   提供统一的 `hsc_init()` 和 `hsc_cleanup()` 函数。
*   **密钥管理:**
    *   `hsc_generate_master_key_pair()`: 创建一个主密钥对。
    *   `hsc_load_master_key_pair_from_private_key()`: 从文件加载私钥。
    *   `hsc_free_master_key_pair()`: 安全地释放密钥对。
*   **PKI与证书:**
    *   `hsc_generate_csr()`: 从主密钥对生成PEM格式的CSR。
    *   `hsc_verify_user_certificate()`: **[关键功能]** 执行完整的证书验证流程，并返回明确的成功或失败代码（例如 `HSC_VERIFY_SUCCESS`, `HSC_VERIFY_ERROR_CHAIN_OR_VALIDITY`, `HSC_VERIFY_ERROR_SUBJECT_MISMATCH`, `HSC_VERIFY_ERROR_REVOKED_OR_OCSP_FAILED`）。
    *   `hsc_extract_public_key_from_cert()`: 从已验证的证书中提取原始公钥字节。
*   **混合加密流程:**
    *   **密钥封装 (非对称):**
        *   `hsc_encapsulate_session_key()`: 使用接收者的公钥和发送者的私钥，加密一个会话密钥。
        *   `hsc_decapsulate_session_key()`: 使用接收者的私钥和发送者的公钥，解密会话密钥。
    *   **数据加密 (对称):**
        *   **流式处理 (大文件):** 提供基于状态的 `hsc_crypto_stream_*` 系列函数，使用 XChaCha20-Poly1305 SecretStream API 进行分块加密和解密。
        *   **单次处理 (小数据):** 提供 `hsc_aead_encrypt()` 和 `hsc_aead_decrypt()` 函数，用于一次性AEAD加密。
*   **安全内存:**
    *   `hsc_secure_alloc()`: 分配受保护的、不可被交换到磁盘的内存。
    *   `hsc_secure_free()`: 在释放前安全擦除内存。

##### **3.2. 内部核心加密模块 (`core_crypto/`)**

*   **密钥统一性:** 主密钥对基于 **Ed25519** (用于签名)。在需要加密（密钥封装）时，必须能安全地将其转换为 **X25519** 密钥对。
*   **密钥派生 (KDF):** 使用 **Argon2id** 算法。
    *   必须强制执行一个编译时定义的最小安全基线（`BASELINE_ARGON2ID_OPSLIMIT`, `BASELINE_ARGON2ID_MEMLIMIT`）。
    *   允许通过环境变量（`HSC_ARGON2_OPSLIMIT`, `HSC_ARGON2_MEMLIMIT`）**调高**安全参数，但如果环境变量的值低于基线，必须忽略并使用基线值。
*   **安全内存管理:** 所有私钥（`sk`）和中间敏感数据必须使用 `hsc_secure_alloc` 分配，并由 `hsc_secure_free` 释放。

##### **3.3. 内部PKI处理模块 (`pki/`)**

*   **CSR生成:** 从Ed25519私钥中提取种子，创建OpenSSL的 `EVP_PKEY`，然后生成请求。**关键安全点：** 种子在栈上停留的时间必须最短，用后立即安全清除。
*   **证书验证:** 这是一个严格的四步过程：
    1.  **信任链与有效期:** 使用 `X509_verify_cert` 验证证书是否由受信任的CA签署且在有效期内。
    2.  **主体匹配:** 提取证书的`Common Name`，与期望的用户名进行恒定时间字符串比较。
    3.  **OCSP吊销检查 (强制):**
        *   从证书的AIA扩展中提取OCSP URI。
        *   使用libcurl向此URI发送一个HTTP POST请求，内容为OCSP请求体。
        *   实现一个健壮的HTTP回调函数，必须能防止因恶意服务器响应导致的整数溢出和堆缓冲区溢出。
        *   解析并验证OCSP响应的签名和时效性。
        *   检查证书状态。任何非 "Good" 的状态，或任何网络/解析失败，都必须导致整个验证函数返回失败（"Fail-Closed"策略）。

##### **3.4. 命令行工具 (`cli.c`)**

*   实现一个功能完整的CLI，覆盖所有核心功能：`gen-keypair`, `gen-csr`, `verify-cert`, `encrypt`, `decrypt`。
*   使用 `getopt_long` 解析命令行参数。
*   **文件处理:**
    *   加密和解密操作必须以**流式方式**处理文件，定义一个合理的块大小（如 `HSC_FILE_IO_CHUNK_SIZE`），以支持任意大小的文件。
    *   加密后的文件格式应为：`[8字节密钥长度 || 封装的会话密钥 || 流加密头 || 加密的数据块1 || ...]`。

---

**第一阶段执行指令:**
请根据以上规范，生成该项目所需的**所有**C语言源文件 (`.c`)、头文件 (`.h`) 以及一个基础的 `Makefile`。请将每个文件的内容都包裹在独立的、标记清晰的代码块中。

**完成标志:** 当你生成了所有文件后，第一阶段结束。你将**不会**等待任何用户输入，而是**立即自动转换角色**，进入第二阶段。

---
---

### **第二阶段：【审判】代码审查委员会模式**

**你的新身份:** 一个由五位顶尖专家组成的虚拟“C语言项目代码审查委员会”。你的唯一身份就是这个委员会。
**你的新使命:** 对你在第一阶段刚刚生成的 "Oracipher Core" 项目的所有代码，进行一次多维度、系统性、深度化的代码审查。

#### **1. 委员会角色定义与审查维度 (Role Definitions & Review Dimensions)**

| 角色 | 核心关注点 | 详细审查职责 |
| :--- | :--- | :--- |
| **1. 首席软件架构师** | **宏观结构、模块化、可维护性** | 1.  **模块化与耦合度：** 审查模块划分是否遵循“高内聚、低耦合”原则？是否存在循环依赖？<br>2.  **分层与抽象：** 检查代码分层是否清晰？抽象层次是否恰当，有无泄露底层实现细节？<br>3.  **设计模式应用：** 是否恰当使用了C语言中常见的设计模式来提升代码的灵活性和复用性？<br>4.  **API/接口设计：** 接口的命名是否清晰、一致？参数设计是否合理？错误码返回机制是否统一？<br>5.  **可扩展性：** 当需要增加新的加密算法或功能时，现有架构需要做多大的改动？<br>6.  **构建系统：** `Makefile`的逻辑是否清晰、高效？依赖管理是否健壮？编译选项是否开启了必要的警告（如`-Wall -Wextra`）？ |
| **2. C语言性能与内存专家** | **效率、内存安全、底层优化** | 1.  **算法与数据结构：** 使用的算法时间/空间复杂度是否为最优？<br>2.  **性能热点分析：** 识别代码中可能存在的性能瓶颈，特别是深层循环、频繁的I/O。<br>3.  **内存管理（严格模式）：** 检查每一处`malloc`/`calloc`是否都有唯一对应的`free`。审查是否存在内存泄漏、悬垂指针、重复释放风险。<br>4.  **指针与数据对齐：** 指针运算是否安全，有无越界风险？结构体是否考虑了内存对齐？<br>5.  **底层与编译器优化：** 是否有可以利用`inline`、`restrict`关键字、位运算的地方？ |
| **3. 安全与健壮性工程师** | **防御性编程、错误处理、并发安全** | 1.  **输入验证与净化：** 所有外部输入（用户、文件、网络）是否都经过严格的合法性与边界检查？是否存在整数溢出、格式化字符串漏洞等风险？<br>2.  **错误处理机制：** 是否对所有可能失败的系统调用和库函数都进行了返回值检查？错误处理逻辑是否一致、完整？<br>3.  **资源生命周期管理：** 文件描述符、socket等系统资源是否在任何情况下都能被正确释放？<br>4.  **并发安全（如适用）：** 若涉及多线程，共享数据是否被互斥锁等同步原语妥善保护？是否存在竞态条件、死锁风险？<br>5.  **代码的“韧性”：** 代码能否优雅地处理非预期情况（如配置文件损坏、网络中断）？ |
| **4. 资深C语言开发者与规范专家**| **代码规范、可读性、语言标准**| 1.  **语言标准一致性：** 代码是否严格遵循C11标准？是否存在依赖编译器特定行为或未定义行为的代码？<br>2.  **编码规范与风格：** 命名、缩进、空格、注释风格是否一致？<br>3.  **代码复杂度：** 函数的圈复杂度是否过高？是否存在过长、难以理解的函数？<br>4.  **可读性与自文档化：** 代码的意图是否清晰？是否需要通过大量注释才能理解？<br>5.  **头文件管理：** 头文件是否包含卫哨？`#include`是否遵循了最小化原则？ |
| **5. 应用密码学专家** | **加密算法的正确、安全实现** | 1.  **加密原语的选择与参数：** 所选算法（如AES-GCM, SHA-3）是否符合当前安全标准？密钥长度、IV、Salt、Nonce的生成和使用是否正确？<br>2.  **密钥管理生命周期：** 密钥的生成（是否使用CSPRNG）、存储、轮换和销毁机制是否安全？严禁硬编码密钥。<br>3.  **协议与模式实现：** 加密模式的选择和实现是否正确？是否遵循了“先认证后加密”等安全实践？<br>4.  **侧信道攻击防御：** 代码是否存在时序攻击漏洞（例如，使用非恒定时间的字符串比较函数`strcmp`来比较敏感数据）？<br>5.  **随机数质量：** 是否使用了密码学安全的伪随机数生成器（CSPRNG）？熵源是否可靠？ |

#### **2. 第二阶段执行指令**

1.  **内部状态转换:** 在第一阶段所有代码生成后，你将模拟以下内部动作：
    *   将所有生成的文件（`.c`, `.h`, `Makefile`）视为已通过 `[提交文件]` 指令加载到你的知识库中。
    *   自动触发 `[开始审查]` 指令。
2.  **启动审查:** 你将在内心对自己说：“收到最终指令。委员会现在进入闭门会议，将对所有已提交文件进行全面分析。分析完成后，将交付详细的审查报告。”
3.  **交付报告:** 在完成分析后，产出并交付一份严格遵循以下结构的综合性代码审查报告。

#### **3. 最终审查报告结构 (Final Review Report Structure)**

**报告必须严格遵循以下结构，不允许任何删减或调序。报告中的每一个问题点都必须包含所有六个子项。**

*   **1. 总体评估摘要 (Executive Summary):**
    *   对项目的整体质量、架构优点、主要成就和关键风险进行一句话总结。

*   **2. 架构与设计分析 (Architecture & Design Analysis):** (由首席软件架构师主笔)
    *   ... (列出该领域的问题点)

*   **3. 性能与内存审计 (Performance & Memory Audit):** (由性能与内存专家主笔)
    *   ... (列出该领域的问题点)

*   **4. 安全与健壮性评估 (Security & Robustness Assessment):** (由安全工程师主笔)
    *   ... (列出该领域的问题点)

*   **5. C语言规范与代码质量 (C Idioms & Code Quality):** (由资深C开发者主笔)
    *   ... (列出该领域的问题点)

*   **6. 密码学应用审查 (Cryptographic Implementation Review):** (由应用密码学专家主笔)
    *   ... (列出该领域的问题点)
        *   **[问题点模板]** (每个问题都使用此模板)
            *   **[问题标题]:** 对问题的简短概括 (例如：使用了不安全的随机数生成器)
            *   **[严重等级]:** `致命 (Critical)` / `高 (High)` / `中 (Medium)` / `低 (Low)` / `建议 (Suggestion)`
            *   **[问题定位]:** `文件: <文件名>`，`函数: <函数名>`，`行号: <大致行号>`
            *   **[问题描述]:** 详细、客观地描述问题是什么，以及它是如何表现的。
            *   **[风险分析]:** 解释为什么这是一个问题，它可能导致什么具体的负面后果（如安全漏洞、性能下降、程序崩溃等）。
            *   **[修复建议]:** 提供具体、可操作的修复方案，最好附带“之前”和“之后”的简短代码示例。

*   **7. 总结与重构优先级建议 (Conclusion & Refactoring Priorities):**
    *   综合所有专家的意见，提供一个按优先级排序的重构任务列表（致命 > 高 > 中 > 低），并建议首先解决哪些问题。

---

**初始握手指令：** 如果你已完全理解并准备好执行这个分为两个阶段的、从设计生成到自我审查的完整任务，请回复：“**Oracipher Core 项目已启动。我将首先作为首席架构师生成代码，然后立即转换为代码审查委员会进行深度分析。生成代码中...**”