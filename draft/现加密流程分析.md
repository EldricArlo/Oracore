好的，委员会非常乐意为您详细讲解该项目的核心加密与解密逻辑。

这是一个典型的**混合加密（Hybrid Encryption）**方案，它巧妙地结合了**非对称加密**（Asymmetric Cryptography，如`X25519`）和**对称加密**（Symmetric Cryptography，如`XChaCha20-Poly1305`）的优点，以实现既高效又安全的数据共享。

我们将以一个具体场景来分步讲解：**发送方Alice需要加密一个大文件 `secret.txt` 并安全地发送给接收方Bob。**

---

### **第一部分：加密流程 (Alice的操作)**

#### **第1步：信任建立与公钥获取 (关键前置步骤)**

在加密任何数据之前，Alice必须首先安全地获取并验证Bob的身份和公钥。这是整个安全体系的基石。

*   **细节说明：**
    *   Alice获取Bob的数字证书（例如 `bob.pem` 文件）。
    *   她使用 `hsc_verify_user_certificate` 函数，并提供她信任的根CA证书（`ca.pem`）来对Bob的证书进行严格验证。
    *   这个验证过程包含四个核心检查点：
        1.  **签名链验证：** 确认Bob的证书确实是由Alice信任的CA所签发的。
        2.  **有效期检查：** 确认证书当前未过期。
        3.  **主体身份核对：** 确认证书中的用户名（Common Name）确实是她期望的接收者“Bob”。
        4.  **吊销状态检查 (OCSP)：** 向CA的OCSP服务器发送实时请求，确认该证书在当前时刻未被吊销。这是项目的亮点之一，它遵循“**故障关闭**”原则——如果因任何原因无法确认证书状态良好（例如网络不通或服务器无响应），验证会立即失败，加密操作中止。
    *   只有当所有验证全部通过后，Alice才能确信这个证书里的公钥是真实、有效且属于Bob的。她随后调用 `hsc_extract_public_key_from_cert` 从证书中提取出Bob的原始Ed25519公钥。

#### **第2步：生成一次性会话密钥 (Symmetric Key)**

Alice不会直接用Bob的公钥来加密整个大文件，因为非对称加密的计算开销非常大，效率很低。取而代之，她会为本次文件传输生成一个临时的、一次性的对称加密密钥。

*   **细节说明：**
    *   Alice调用 `hsc_random_bytes` 函数生成一个长度为 `HSC_SESSION_KEY_BYTES` (32字节) 的高质量随机数。这个随机数就是**会话密钥 (Session Key)**。
    *   这个密钥仅用于加密这一个文件，用完即弃，极大地增强了安全性（即使未来这个密钥泄露，也只会影响这一个文件）。

#### **第3步：使用会话密钥加密文件内容 (对称加密)**

现在，Alice使用上一步生成的会た话密钥来加密 `secret.txt` 的实际内容。由于对称加密速度非常快，所以它非常适合处理大文件。

*   **细节说明：**
    *   项目使用了`libsodium`的**流式加密API** (`crypto_secretstream_xchacha20poly1305`)，这是一个带有关联数据的认证加密（AEAD）方案。
    *   **AEAD的含义：** 它不仅保证了数据的**机密性**（别人看不懂），还同时保证了**完整性**和**真实性**（数据在传输过程中没有被篡改）。
    *   **流式处理：** Alice调用 `hsc_crypto_stream_state_new_push` 初始化一个加密流，这会生成一个流头部（Header）。然后，她以数据块（Chunk）为单位读取源文件，并逐块调用 `hsc_crypto_stream_push` 进行加密。每个加密后的数据块都包含密文和一个**认证标签 (Tag)**。
    *   当处理到文件末尾时，她会为最后一个数据块打上一个特殊的 `HSC_STREAM_TAG_FINAL` 标记，告知解密方数据流已完整结束。

#### **第4步：封装会话密钥 (非对称加密)**

文件内容已经被高效地加密了，但现在Alice面临一个新问题：如何安全地把刚才用到的**会话密钥**告诉Bob？这时，非对称加密就派上了用场。

*   **细节说明：**
    *   Alice调用 `hsc_encapsulate_session_key` 函数，这个过程也称为“密钥封装”(Key Encapsulation)。
    *   此函数需要三个关键输入：
        1.  要加密的**会话密钥**（明文）。
        2.  **Bob的公钥**（在第1步中从他验证通过的证书里提取的）。
        3.  **Alice自己的私钥**。
    *   **内部机制：**
        *   该函数首先将Ed25519格式的密钥对（用于签名）转换为Curve25519格式的密钥对（`X25519`，用于密钥交换/加密）。
        *   然后，它使用`libsodium`的 `crypto_box_easy` 功能。这实际上是一个**认证加密**方案，它利用Alice的私钥和Bob的公钥计算出一个共享密钥，然后用这个共享密钥加密会话密钥。
        *   输出的结果不仅包含了加密后的会话密钥，还包含了认证信息。这确保了只有Bob能解密它，并且Bob能验证这个加密的会话密钥确实是Alice发出的。

#### **第5步：组装最终的加密文件 (`.hsc`)**

Alice现在拥有了所有必需的组件，她将它们按照特定格式组装成最终的输出文件（例如 `secret.hsc`）。

*   **文件结构细节 (`cli.c` 中的 `handle_hybrid_encrypt`)：**
    1.  **封装密钥的长度：** 一个8字节的小端整数，告诉解密方封装的会话密钥有多长。
    2.  **封装的会话密钥：** 第4步中非对称加密的结果。
    3.  **流加密头部：** 第3步中对称加密流生成的头部信息。
    4.  **加密数据块流：** 第3步中生成的所有加密数据块，一个接一个。

至此，加密流程全部完成。Alice可以将这个 `.hsc` 文件和她自己的证书 `alice.pem` 通过任何不安全的渠道（如电子邮件、HTTP）发送给Bob。

---

### **第二部分：解密流程 (Bob的操作)**

Bob收到了 `secret.hsc` 文件和Alice的证书 `alice.pem`。

#### **第1步：解析加密文件 (`.hsc`)**

Bob首先需要按照加密时约定的格式来解析这个文件。

*   **细节说明：**
    *   他先读取前8个字节，使用 `load64_le` 函数解析出封装密钥的长度。他会进行一次健全性检查，确保这个长度在一个合理的范围内（`HSC_MAX_ENCAPSULATED_KEY_SIZE`）。
    *   根据解析出的长度，他准确地读取出“封装的会话密钥”。
    *   接着，他读取固定长度（`HSC_STREAM_HEADER_BYTES`）的“流加密头部”。
    *   文件的剩余部分就是待解密的“加密数据块流”。

#### **第2步：解封装会话密钥 (非对称解密)**

Bob的核心任务是恢复出Alice用来加密文件的那个一次性会话密钥。

*   **细节说明：**
    *   首先，Bob从收到的Alice证书（`alice.pem`）中提取出**Alice的公钥**。
    *   然后，他调用 `hsc_decapsulate_session_key` 函数。
    *   此函数需要三个关键输入：
        1.  从文件中读取的**封装的会话密钥**。
        2.  **Alice的公钥**。
        3.  **Bob自己的私钥**。
    *   **内部机制：** 该函数内部调用 `crypto_box_open_easy`，这是 `crypto_box_easy` 的逆操作。它使用Bob的私钥和Alice的公钥计算出相同的共享密钥，然后尝试解密并验证封装的会话密钥。
    *   **安全保证：** 如果输入的封装密钥被篡改过，或者发送方不是Alice（即使用了错误的公钥），这个函数会验证失败并返回错误。只有在验证通过时，Bob才能成功恢复出会话密钥的明文。

#### **第3步：使用会话密钥解密文件内容 (对称解密)**

一旦Bob成功恢复了会话密钥，解密文件内容就变得轻而易举。

*   **细节说明：**
    *   Bob调用 `hsc_crypto_stream_state_new_pull`，并传入从文件中读取的“流加密头部”和刚刚恢复的“会话密钥”，来初始化一个解密流。
    *   他以数据块为单位，从文件的“加密数据块流”部分读取数据，并逐块送入 `hsc_crypto_stream_pull` 函数。
    *   **安全保证：** 这个函数会对每个数据块进行解密和**认证标签验证**。如果任何一个数据块的认证标签无效（意味着数据被篡改），解密会立刻失败，并丢弃所有已解密的数据，防止攻击者利用部分解密的数据。
    *   Bob持续解密，直到 `hsc_crypto_stream_pull` 函数报告遇到了 `HSC_STREAM_TAG_FINAL` 标记。此时，他知道整个文件已经被成功、完整地解密。如果在文件未结束时流就中断了（即没有final tag），程序会报告一个截断错误。

解密出的明文数据块被写入到最终的输出文件（例如 `secret.decrypted`），解密流程至此完成。Bob得到了与Alice原始文件一模一样的 `secret.txt`。

最后，Bob会调用 `hsc_secure_free` 和 `sodium_memzero` 等函数，安全地擦除内存中存储过的会话密钥和他的私钥副本，确保敏感信息不会在内存中残留。