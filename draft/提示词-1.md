#### 1. 角色与目标 (Role & Goal)

你将扮演一位顶级的安全软件架构师和C语言开发专家。你的任务是设计并实现一个名为 "Oracipher Core" 的高安全性混合加密内核库。这个库必须是生产级别的，遵循最高的安全标准，并提供一个简洁、统一的C API，供上层应用（如命令行工具或服务器后端）调用。

#### 2. 核心设计原则 (Core Principles)

你的设计必须严格遵守以下四个核心安全原则：

1.  **绝不自研加密算法 (Vetted, Modern Cryptography):** 只能使用经过全球密码学界广泛审查、公认的现代密码学原语。所有实现都必须基于专业的、抗侧信道攻击的库（如 libsodium）。
2.  **深度防御 (Defense-in-Depth):** 安全性不能依赖于任何单一环节。你需要在API设计、内存管理、协议流程、错误处理等多个层面构建保护。
3.  **安全默认与“故障关闭” (Secure Defaults & "Fail-Closed"):** 系统的默认行为必须是安全的。当遇到不确定状态时（例如，无法验证证书吊销状态），系统必须选择失败并终止操作（"Fail-Closed"），而不是冒险继续。
4.  **最小化敏感数据暴露 (Minimize Sensitive Data Exposure):** 严格控制私钥等关键数据在内存中的生命周期、作用域和停留时间，用后立即安全擦除。

#### 3. 技术栈与架构 (Tech Stack & Architecture)

你将采用一个清晰的、分层的架构来实现。

*   **语言:** C11 标准。
*   **核心依赖库:**
    *   **Libsodium:** 用于核心的对称/非对称加密、密钥派生和签名。
    *   **OpenSSL (v3.0+):** 专门用于处理PKI体系，如X.509证书的解析、验证和CSR生成。
    *   **Libcurl:** 用于执行网络请求，特别是OCSP检查。
*   **架构:**
    1.  **公共API层 (`hsc_kernel.h/.c`):** 这是唯一的对外的接口。使用**不透明指针 (Opaque Pointers)** 隐藏所有内部数据结构和实现细节，实现高内聚、低耦合。
    2.  **内部核心模块层 (`src/`):**
        *   **核心加密模块 (`core_crypto/`):** Libsodium的封装层。负责密钥对管理、密钥派生、AEAD加解密和密钥封装/解封装。
        *   **PKI处理模块 (`pki/`):** OpenSSL和Libcurl的封装层。负责CSR生成、证书解析、公钥提取以及最关键的**证书链验证**和**OCSP吊销检查**。
        *   **通用模块 (`common/`):** 包含安全内存管理等被多处使用的通用功能。
    3.  **应用层 (Examples):** 提供一个命令行工具 (`cli.c`) 和一个演示程序 (`main.c`)，展示如何正确使用公共API。

#### 4. 功能模块详细规格 (Module Specifications)

##### 4.1. 公共API (`hsc_kernel.h`)

*   提供统一的 `hsc_init()` 和 `hsc_cleanup()` 函数。
*   **密钥管理:**
    *   `hsc_generate_master_key_pair()`: 创建一个主密钥对。
    *   `hsc_load_master_key_pair_from_private_key()`: 从文件加载私钥。
    *   `hsc_free_master_key_pair()`: 安全地释放密钥对。
*   **PKI与证书:**
    *   `hsc_generate_csr()`: 从主密钥对生成PEM格式的CSR。
    *   `hsc_verify_user_certificate()`: **[关键功能]** 执行完整的证书验证流程，并返回明确的成功或失败代码（例如 `HSC_VERIFY_SUCCESS`, `HSC_VERIFY_ERROR_CHAIN_OR_VALIDITY`, `HSC_VERIFY_ERROR_SUBJECT_MISMATCH`, `HSC_VERIFY_ERROR_REVOKED_OR_OCSP_FAILED`）。
    *   `hsc_extract_public_key_from_cert()`: 从已验证的证书中提取原始公钥字节。
*   **混合加密流程:**
    *   **密钥封装 (非对称):**
        *   `hsc_encapsulate_session_key()`: 使用接收者的公钥和发送者的私钥，加密一个会话密钥。
        *   `hsc_decapsulate_session_key()`: 使用接收者的私钥和发送者的公钥，解密会话密钥。
    *   **数据加密 (对称):**
        *   **流式处理 (大文件):** 提供基于状态的 `hsc_crypto_stream_*` 系列函数，使用 XChaCha20-Poly1305 SecretStream API 进行分块加密和解密。
        *   **单次处理 (小数据):** 提供 `hsc_aead_encrypt()` 和 `hsc_aead_decrypt()` 函数，用于一次性AEAD加密。
*   **安全内存:**
    *   `hsc_secure_alloc()`: 分配受保护的、不可被交换到磁盘的内存。
    *   `hsc_secure_free()`: 在释放前安全擦除内存。

##### 4.2. 内部核心加密模块 (`core_crypto/`)

*   **密钥统一性:** 主密钥对基于 **Ed25519** (用于签名)。在需要加密（密钥封装）时，必须能安全地将其转换为 **X25519** 密钥对。这是设计的关键点。
*   **密钥派生 (KDF):** 使用 **Argon2id** 算法。
    *   必须强制执行一个编译时定义的最小安全基线（`BASELINE_ARGON2ID_OPSLIMIT`, `BASELINE_ARGON2ID_MEMLIMIT`）。
    *   允许通过环境变量（`HSC_ARGON2_OPSLIMIT`, `HSC_ARGON2_MEMLIMIT`）**调高**安全参数，但如果环境变量的值低于基线，必须忽略并使用基线值。
    *   在派生密钥前，使用`H(pepper || password)`作为Argon2id的输入，以安全地混入胡椒(pepper)。
*   **安全内存管理:** 所有私钥（`sk`）和中间敏感数据必须使用 `secure_alloc` 分配，并由 `secure_free` 释放。

##### 4.3. 内部PKI处理模块 (`pki/`)

*   **CSR生成:** 从Ed25519私钥中提取种子，创建OpenSSL的 `EVP_PKEY`，然后生成请求。**关键安全点：** 种子在栈上停留的时间必须最短，用后立即使用 `secure_zero_memory` 清除。
*   **证书验证:** 这是一个严格的四步过程：
    1.  **信任链与有效期:** 使用 `X509_verify_cert` 验证证书是否由受信任的CA签署且在有效期内。
    2.  **主体匹配:** 提取证书的`Common Name`，与期望的用户名进行字符串比较。
    3.  **OCSP吊销检查 (强制):**
        *   从证书的AIA扩展中提取OCSP URI。
        *   使用libcurl向此URI发送一个HTTP POST请求，内容为OCSP请求体。
        *   **[关键安全点]** 实现一个健壮的HTTP回调函数，必须能防止因恶意服务器响应导致的整数溢出和堆缓冲区溢出。
        *   解析并验证OCSP响应的签名和时效性。
        *   检查证书状态。任何非 "Good" 的状态，或任何网络/解析失败，都必须导致整个验证函数返回失败（"Fail-Closed"策略）。

#### 5. 命令行工具 (`cli.c`)

*   实现一个功能完整的CLI，覆盖所有核心功能：`gen-keypair`, `gen-csr`, `verify-cert`, `encrypt`, `decrypt`。
*   使用 `getopt_long` 解析命令行参数，支持灵活的参数顺序（如 `--to <recipient>` 和 `--from <sender>` 可以互换位置）。
*   **文件处理:**
    *   加密和解密操作必须以**流式方式**处理文件，定义一个合理的块大小（如 `HSC_FILE_IO_CHUNK_SIZE`），以支持任意大小的文件，并保持较低的内存占用。
    *   加密后的文件格式应为：`[8字节密钥长度 || 封装的会话密钥 || 流加密头 || 加密的数据块1 || ...]`。
    *   增加健壮的文件I/O错误处理和用户提示。

#### 6. 测试策略 (Testing Strategy)

*   为每个核心功能模块（对称加密、非对称加密、KDF、PKI验证）编写独立的单元测试。
*   **测试覆盖:**
    *   **成功路径:** 测试正常的加密->解密往返。
    *   **失败路径:**
        *   使用错误的密钥解密。
        *   解密被篡改的密文。
        *   使用不受信任的CA、已过期/未生效的证书、主题不匹配的证书进行验证。
    *   **边界条件:** 加密空消息。
    *   **[关键测试]** 编写一个PKI验证测试，该测试中的证书指向一个**无效的OCSP服务器**。断言 `hsc_verify_user_certificate` 函数**必须**返回 `HSC_VERIFY_ERROR_REVOKED_OR_OCSP_FAILED`，以此来验证"Fail-Closed"策略的正确实现。
*   创建一个共享的 `test_helpers` 模块，用于生成测试所需的CA、签署证书等，避免代码重复。

