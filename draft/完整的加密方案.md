### **高安全性混合加密系统技术规范 - 版本 4.0 (纵深防御 PKI 框架)**

**版本**: 4.0 (最终版)
**状态**: 生产环境就绪 (Production Ready)
**核心思想**: 本规范将 v3.2 的**客户端主动防御**和**基础设施硬化**理念，与 v3.3 的**行业标准公钥基础设施 (PKI)** 进行深度融合，构建一个**可验证、抗降级、具备主动威胁预警能力**的零知识加密框架。

---

### **1. 核心设计原则 (Principles)**

本规范的设计严格遵循以下不可违背的原则：

1.  **彻底的零知识 (Zero Knowledge)**: 服务器在任何时候都**绝不能**接触到能解密用户数据的任何明文密钥（包括密码、主私钥、恢复密钥、派生密钥）。
2.  **严格的客户端加密 (Client-Side Cryptography)**: 所有敏感的加密、解密、密钥派生及签名操作**必须**在用户设备上完成。
3.  **可验证的信任锚 (Verifiable Trust Anchors)**: 系统中所有用于建立信任的公钥，其与用户身份的绑定关系**必须**通过标准的、客户端可独立验证的 X.509 证书链进行证明。
4.  **纵深防御 (Defense-in-Depth)**: 系统的每一层都应假设其他层可能被攻破，并内置独立的、主动的安全机制，包括客户端参数校验、基础设施硬件安全和主动威胁警报。

---

### **2. 核心基础设施组件 (Infrastructure Components)**

*   **系统证书颁发机构 (System CA)**
    *   **职责**: 作为系统的信任根，负责为所有合法用户签发、续期 X.509 数字证书，权威地证明用户身份与其`主公钥`的绑定关系。
    *   **安全要求 (强制)**:
        *   CA 的根证书和私钥**必须**在离线的、经过 FIPS 140-2 Level 3 或更高认证的**硬件安全模块 (HSM)** 中生成和存储。
        *   日常签发操作应通过一个在线的、受严格访问控制的“签发子 CA”完成，形成安全的、可隔离风险的分层结构。
*   **证书吊销与透明度服务 (Revocation & Transparency Service)**
    *   **职责**: 维护并提供一个实时的、公开可查的证书吊销状态。同时，为增强系统的可审计性，所有签发的证书记录都应发布到一个类似**证书透明度 (Certificate Transparency)** 的防篡改日志中。
    *   **实现 (强制)**:
        *   **吊销检查**: 客户端在验证证书时**必须**通过 **OCSP (在线证书状态协议)** 查询证书的实时状态。OCSP 服务必须是高可用的。
        *   **审计日志**: 服务器应维护一个公开可审计的、基于 Merkle 树的日志，记录所有证书的签发历史。这继承了 v3.2“密钥透明性”的可审计精神，并将其应用于 PKI 框架。
*   **秘密预言机服务 (Secret Oracle Service)**
    *   **职责**: 安全地存储和分发版本化的`全局胡椒 (Global Pepper)`。
    *   **安全要求 (强制)**: 该服务**必须**将其管理的全局胡椒安全地存储在**硬件安全模块 (HSM)** 中。服务自身无权直接读取胡椒明文，所有操作都应在 HSM 内部完成。

---

### **3. 客户端安全强制规范 (Client-Side Mandates)**

*   **抗降级攻击 (Anti-Downgrade Attack)**
    *   客户端**必须**内置一套符合当前业界最佳实践的**最小 Argon2id 安全参数基线**。在执行 KDF 前，**必须**验证从服务器获取的参数不低于此内置基线。若低于，则**必须**中止操作并向用户报告安全风险。
*   **抗侧信道攻击 (Side-Channel Resistance)**
    *   所有在客户端执行的密码学操作（如 ECIES, AEAD, Argon2id）**必须**调用确保**恒定时间 (Constant-Time) 执行**的密码学库实现，以防止通过功耗、时序等旁路信息推断密钥。
*   **安全内存管理 (Secure Memory Management)**
    *   任何在内存中出现的敏感明文数据（如`密码`, `主私钥`, `恢复密钥`）**必须**在使用完毕后，被立即、可靠地从内存中清除（置零），最小化敏感数据在内存中的生命周期。

---

### **4. 详细工作流程 (Detailed Workflows)**

#### **阶段一：用户账户创建与证书初始化**

1.  **本地输入与密钥生成**: 用户输入`用户名`和`密码`。客户端在本地生成`用户盐`和`主密钥对 (MasterKeyPair)`。(v3.2)
2.  **生成并强制备份恢复密钥**: 客户端生成`恢复密钥`，并通过 Shamir 秘密共享算法分割成多个`分片`。客户端**必须**以模态框等强交互形式，引导用户将分片下载为带明确警告的加密备份文件，并要求用户勾选确认“我已在离线环境中安全备份”，方可继续。(v3.2 强化)
3.  **零知识注册 (OPAQUE)**: 客户端与服务器完成 OPAQUE 协议，向服务器证明密码所有权并建立安全的会话，服务器不知道用户密码。(v3.2 & v3.3)
4.  **生成并提交证书签名请求 (CSR)**:
    a. 在 OPAQUE 认证成功后，客户端使用`主私钥`生成一个包含`主公钥`及用户标识（如`Username`）的 **CSR**。(v3.3)
    b. 客户端将此 CSR 通过已建立的安全会话发送给服务器。
5.  **CA 签发与分发**:
    a. 服务器校验 CSR 后，将其转发给**系统 CA**。(v3.3)
    b. **系统 CA** 验证请求合法性，然后签发一份 **X.509 用户证书**，并将该签发记录计入公共审计日志。(v3.3)
    c. CA 将签发好的证书返回给服务器，再由服务器返回给客户端。
6.  **上传加密数据与证书**:
    a. 客户端本地派生密钥，并分别用“密码派生密钥”和“恢复密钥”加密`主私钥`。(v3.2)
    b. 客户端将以下 JSON 对象发送给服务器：`Username`, `Salt`, `Argon2id_Parameters`, `PepperVersion`, **`UserCertificate (PEM格式)`**, `EncryptedMasterPrivateKey_Pwd`, `EncryptedMasterPrivateKey_Rec`。(v3.3)
    c. **服务器操作**: 服务器在数据库中创建用户记录的整个过程**必须**被封装在**原子事务 (Atomic Transaction)** 中，以杜绝竞争条件。(v3.2)

#### **阶段二：用户认证与会话初始化**

1.  **零知识认证 (OPAQUE)**: 用户输入密码，客户端与服务器完成 OPAQUE 认证流程，建立会话。(v3.2)
2.  **获取加密元数据**: 客户端从服务器获取加密所需的所有元数据。(v3.2)
3.  **客户端安全解密**:
    a. 客户端向**秘密预言机服务**请求`全局胡椒`。(v3.2)
    b. **【安全验证点】**: 客户端在收到`Argon2id_Parameters`后，**必须**先与内置的最小安全基线进行对比。验证通过后方可继续。(v3.2)
    c. 在本地执行 `DerivedKey = Argon2id(...)` 派生密钥。
    d. 尝试使用 `DerivedKey` 解密 `EncryptedMasterPrivateKey_Pwd`，在内存中恢复`主私钥`。

#### **阶段三：文件加密与共享 (基于 PKI 的可验证信任)**

1.  **本地加密**: 流程不变，客户端生成`会话密钥`，使用 AEAD 算法加密文件内容。(v3.2)
2.  **安全获取并验证接收者证书**:
    a. 客户端向服务器请求接收者`userId`列表对应的**用户证书**。(v3.3)
    b. **【客户端强制验证】**: 对于获取到的每一个证书，客户端**必须**执行以下**完整的、标准的证书验证流程**：(v3.3)
        i.  **验证签名链**: 使用预置在客户端内的**系统 CA 根证书**，验证该用户证书的签名是否合法。
        ii. **检查有效期**: 确保当前时间在证书的`生效日期`和`失效日期`之间。
        iii. **核对主体**: 检查证书的`主体 (Subject)`字段是否与目标接收者的`userId`匹配。
        iv. **检查吊销状态 (实时)**: 客户端**必须**向系统的 **OCSP 服务**发起实时请求，查询该证书是否已被吊销。
    c. **任何一步验证失败，该证书都必须被拒绝**，并从接收者列表中移除，同时向用户发出警告。(v3.3 & v3.2)
3.  **用户二次验证 (可选但建议)**: 客户端应用**必须**在 UI 显著位置展示接收者证书的**指纹 (Thumbprint)**，鼓励用户通过其他安全渠道（带外验证）与协作者进行最终比对。(v3.2)
4.  **封装会话密钥**: 对于**所有**通过验证的证书，客户端从中提取出可信的`主公钥`，并使用 ECIES 算法分别加密同一个`会话密钥`。(v3.3)
5.  **组装输出**: 流程不变，将加密后的文件内容和封装好的各接收者会话密钥组装成最终文件。

#### **阶段四：账户恢复 (主动预警与安全闭环)**

1.  **启动与重组**: 用户提供足够的恢复分片，客户端在本地重组出`恢复密钥`。(v.3.2)
2.  **通信与主动预警**:
    a. 客户端向服务器请求该账户的`EncryptedMasterPrivateKey_Rec`。(v3.2)
    b. **【主动预警】**: 服务器在收到请求后，**必须立即**（在返回数据之前）通过该账户关联的所有已验证联系方式（备用邮箱、推送通知等）发送一条**高优先级安全警报**。(v3.2)
        *   **警报内容模板**: "安全警报：您的账户正在尝试使用恢复密钥进行恢复。如果这不是您本人操作，您的账户可能已被盗用。请立即[点击链接]采取紧急措施。"
    c. 服务器在发送警报后，执行严格的速率限制，然后再向请求方返回数据。(v3.2)
3.  **客户端解密与强制重置**:
    a. 客户端使用重组的`恢复密钥`解密`EncryptedMasterPrivateKey_Rec`，恢复`主私钥`。(v3.2)
    b. 恢复成功后，系统**必须强制**用户立即设置新的`密码`并生成一套全新的`恢复密钥`。(v3.2)
4.  **【安全闭环】证书轮换**:
    a. 在设置新密码后，客户端**必须**生成一个**新的主密钥对**。(v3.3)
    b. 客户端立即发起一个新的 **CSR** 流程（如阶段一），为新的主公钥获取一份**新的用户证书**。(v3.3)
    c. 当新证书成功获取并替换本地旧证书后，服务器**必须**立即将**旧证书**的序列号添加到 **OCSP/CRL 吊销列表**中。(v3.3)

---

### **5. 实施与验证的强制要求 (Implementation Mandates)**

*   **形式化验证 (Formal Verification)**: 核心密码协议（如 OPAQUE 集成、密钥封装流程）**必须**使用 ProVerif 或 Tamarin 等工具进行形式化建模和验证，以证明其能抵御各类逻辑攻击。验证报告需归档备查。(v3.2)
*   **代码与库要求**: 所有密码学代码**必须**使用经过社区广泛审查的、实现了恒定时间算法和安全内存管理的专业密码学库。禁止自行发明或实现密码学原语。(v3.2 强化)
