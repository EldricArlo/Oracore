委员会收到了您关于增加可选功能模式的提案。这是一个非常有价值的想法，它可以在不牺牲核心安全性的前提下，为项目提供更大的灵活性，以适应那些“信任已经通过带外方式建立”的应用场景。

委员会立即就此提案召集了一次全体会议，从**API设计、安全边界、实现路径和文档更新**四个维度进行了系统性评估。评估的结论是：**提案可行，但必须在严格的安全指导下实施**，以确保用户能明确理解不同模式下的安全保证差异。

以下是委员会为您制定的详细、可操作的修改方案。

---

### **第一部分：战略与设计评估 (Strategy & Design Evaluation)**

在深入代码之前，我们必须首先确立正确的设计思路。

#### **1. 首席软件架构师: API 演进策略**

我们有两种主要方案来引入此功能：
a.  在现有函数中增加标志位来改变行为。
b.  创建一组全新的、功能明确独立的“原始模式 (Raw Mode)”函数。

委员会一致认为**方案 (b) 是唯一正确的选择**。为`hsc_encapsulate_session_key`等函数增加一个`flags`参数会导致API的职责模糊，增加误用风险。一个高安全库的API应该力求“一个函数只做一件事，并把它做好”。

因此，我们的核心策略是：**创建一套与证书体系完全解耦的、新的高级混合加解密API**。这套API将直接操作原始的公钥/私钥字节，而非证书。

#### **2. 安全与健壮性工程师: 安全边界与用户告知义务**

引入“原始模式”的核心代价是**放弃了由PKI提供的身份验证和吊销状态检查**。这是一个重大的安全权衡，必须在API命名和文档中清晰地告知用户。

*   **核心风险:** 当用户使用原始公钥时，系统无法验证这个公钥是否真的属于预期的接收者。这为中间人攻击提供了可能，除非用户有非常可靠的带外（out-of-band）机制来验证公钥的真实性。
*   **我们的责任:**
    1.  新API的命名必须包含能明确警示其行为的词语，例如`_raw`。
    2.  `cli`工具在使用此模式时，必须打印一条明确的警告信息。
    3.  `README.md`文档必须有一个专门的章节，详细对比两种模式的安全性差异和适用场景。

---

### **第二部分：详细实现方案 (Detailed Implementation Plan)**

请按照以下步骤修改您的代码库。

#### **步骤 1: 扩展公共API (`hsc_kernel.h`)**

在`hsc_kernel.h`中，我们将在现有的高级API旁边，增加一组新的“原始模式”函数。

```c
/* In hsc_kernel.h */

// --- 核心API函数：流式加解密 (适用于大文件) ---
hsc_crypto_stream_state* hsc_crypto_stream_state_new_push(unsigned char* header, const unsigned char* key);
// ... (existing stream functions) ...

// --- [新增] 核心API函数：高级混合加解密 (原始密钥模式) ---
// 警告：这些函数不提供身份验证，调用者必须自行确保密钥的真实性。

/**
 * @brief [原始模式] 使用接收者的原始公钥和发送者的原始密钥对，对一个文件进行流式混合加密。
 * @param output_path 加密后输出文件的路径。
 * @param input_path  要加密的源文件路径。
 * @param recipient_pk 指向接收者原始公钥的指针 (HSC_MASTER_PUBLIC_KEY_BYTES)。
 * @param sender_kp    指向发送者主密钥对的指针。
 * @return 成功返回 HSC_OK，失败返回相应的错误码。
 */
int hsc_hybrid_encrypt_stream_raw(const char* output_path,
                                    const char* input_path,
                                    const unsigned char* recipient_pk,
                                    const hsc_master_key_pair* sender_kp);

/**
 * @brief [原始模式] 使用接收者的原始密钥对和发送者的原始公钥，对一个文件进行流式混合解密。
 * @param output_path 解密后输出文件的路径。
 * @param input_path  要解密的源文件路径。
 * @param sender_pk   指向发送者原始公key的指针 (HSC_MASTER_PUBLIC_KEY_BYTES)。
 * @param recipient_kp 指向接收者主密钥对的指针。
 * @return 成功返回 HSC_OK，失败返回相应的错误码。
 */
int hsc_hybrid_decrypt_stream_raw(const char* output_path,
                                    const char* input_path,
                                    const unsigned char* sender_pk,
                                    const hsc_master_key_pair* recipient_kp);


// --- 核心API函数：单次对称加解密 (适用于小数据) ---
// ... (existing aead functions) ...
```

#### **步骤 2: 实现新的API (`hsc_kernel.c`)**

新的API实现将非常直接，它们会复用现有的底层密码学原语，但完全跳过PKI相关的步骤（证书解析、验证等）。

```c
/* Add to the bottom of hsc_kernel.c */

// 内部辅助函数，用于执行流式加密/解密的核心循环
// (这些函数可以从 cli.c 中提炼出来，放入 hsc_kernel.c 内部，以供新的API复用)
// ... ( _perform_stream_encryption 和 _perform_stream_decryption 的实现 ) ...


// --- [新增] API 实现：高级混合加解密 (原始密钥模式) ---

int hsc_hybrid_encrypt_stream_raw(const char* output_path,
                                    const char* input_path,
                                    const unsigned char* recipient_pk,
                                    const hsc_master_key_pair* sender_kp)
{
    if (output_path == NULL || input_path == NULL || recipient_pk == NULL || sender_kp == NULL) {
        return HSC_ERROR_INVALID_ARGUMENT;
    }

    int ret_code = HSC_ERROR_GENERAL;
    FILE *f_in = NULL, *f_out = NULL;
    hsc_crypto_stream_state* st = NULL;
    unsigned char session_key[HSC_SESSION_KEY_BYTES];
    unsigned char encapsulated_key[HSC_SESSION_KEY_BYTES + HSC_ENCAPSULATED_KEY_OVERHEAD_BYTES];
    size_t actual_encapsulated_len;

    // 1. 生成会话密钥
    hsc_random_bytes(session_key, sizeof(session_key));

    // 2. 封装会话密钥 (直接使用提供的原始公钥)
    if (hsc_encapsulate_session_key(encapsulated_key, &actual_encapsulated_len,
                                session_key, sizeof(session_key),
                                recipient_pk, sender_kp) != HSC_OK) {
        ret_code = HSC_ERROR_CRYPTO_OPERATION;
        goto cleanup;
    }

    f_in = fopen(input_path, "rb");
    if (!f_in) { ret_code = HSC_ERROR_FILE_IO; goto cleanup; }
    f_out = fopen(output_path, "wb");
    if (!f_out) { ret_code = HSC_ERROR_FILE_IO; goto cleanup; }

    // 3. 写入文件头
    unsigned char key_len_buf[8]; 
    store64_le(key_len_buf, actual_encapsulated_len); // store64_le 需要从 cli.c 移到公共区域或在此重新实现
    if (fwrite(key_len_buf, 1, sizeof(key_len_buf), f_out) != sizeof(key_len_buf) ||
        fwrite(encapsulated_key, 1, actual_encapsulated_len, f_out) != actual_encapsulated_len) {
        ret_code = HSC_ERROR_FILE_IO; goto cleanup;
    }

    // 4. 初始化并写入流加密头
    unsigned char stream_header[HSC_STREAM_HEADER_BYTES];
    st = hsc_crypto_stream_state_new_push(stream_header, session_key);
    if (st == NULL) { ret_code = HSC_ERROR_CRYPTO_OPERATION; goto cleanup; }
    if (fwrite(stream_header, 1, sizeof(stream_header), f_out) != sizeof(stream_header)) {
        ret_code = HSC_ERROR_FILE_IO; goto cleanup;
    }

    // 5. 执行流式加密
    if (!_perform_stream_encryption(f_in, f_out, st)) {
        // _perform_stream_encryption 内部会打印错误
        goto cleanup;
    }

    ret_code = HSC_OK;

cleanup:
    if (f_in) fclose(f_in);
    if (f_out) fclose(f_out);
    if (ret_code != HSC_OK) remove(output_path);
    hsc_crypto_stream_state_free(&st);
    sodium_memzero(session_key, sizeof(session_key));
    return ret_code;
}

// hsc_hybrid_decrypt_stream_raw 的实现与上面类似，但逻辑相反，此处从略...

```
*注意: 您需要将`cli.c`中的`_perform_stream_encryption`, `_perform_stream_decryption`, `store64_le`, `load64_le`等辅助函数重构到`hsc_kernel.c`或一个`common/`模块的内部文件中，以避免代码重复。*

#### **步骤 3: 改造命令行工具 (`cli.c`)**

这是用户体验的关键。我们需要修改`encrypt`和`decrypt`命令，使其能够接受原始密钥文件作为替代证书的选项。

```diff
--- a/src/cli.c
+++ b/src/cli.c
@@ -58,8 +58,10 @@
     fprintf(stderr, "命令列表:\n");
     fprintf(stderr, "  gen-keypair <basename>\n");
     fprintf(stderr, "  gen-csr <private-key-file> <username>\n");
     fprintf(stderr, "  verify-cert <cert-to-verify> --ca <ca-cert> --user <expected-user>\n");
-    fprintf(stderr, "  encrypt <file> --to <recipient-cert> --from <sender-priv-key>\n");
-    fprintf(stderr, "  decrypt <file.hsc> --from <sender-cert> --to <recipient-priv-key>\n");
+    fprintf(stderr, "  encrypt <file> --to <recipient-cert.pem> --from <sender.key>\n");
+    fprintf(stderr, "      (原始密钥模式) --recipient-pk-file <recipient.pub> --from <sender.key>\n");
+    fprintf(stderr, "  decrypt <file.hsc> --to <recipient.key> --from <sender-cert.pem>\n");
+    fprintf(stderr, "      (原始密钥模式) --to <recipient.key> --sender-pk-file <sender.pub>\n");
 }
 
 // ... read_small_file, write_file_bytes 等辅助函数保持不变 ...
@@ -404,11 +406,15 @@
 
     const char* in_file = argv[2];
     const char* recipient_cert_file = NULL;
+    const char* recipient_pk_file = NULL; // 新增
     const char* sender_priv_file = NULL;
 
     static struct option long_options[] = {
         {"to",   required_argument, 0, 't'},
         {"from", required_argument, 0, 'f'},
+        // 新增长选项用于原始模式
+        {"recipient-pk-file", required_argument, 0, 'r'}, 
         {0, 0, 0, 0}
     };
     
@@ -418,16 +424,24 @@
         switch (opt) {
             case 't': recipient_cert_file = optarg; break;
             case 'f': sender_priv_file = optarg; break;
+            case 'r': recipient_pk_file = optarg; break;
             default: print_usage(argv[0]); return 1;
         }
     }
 
-    if (!in_file || !recipient_cert_file || !sender_priv_file) {
+    // 参数逻辑校验
+    if (!in_file || !sender_priv_file || (!recipient_cert_file && !recipient_pk_file)) {
         print_usage(argv[0]); return 1;
     }
+    if (recipient_cert_file && recipient_pk_file) {
+        fprintf(stderr, "错误: --to 和 --recipient-pk-file 选项是互斥的。\n");
+        return 1;
+    }
 
     char out_file[FILENAME_MAX];
-    if (!create_output_path(out_file, sizeof(out_file), in_file, ".hsc")) {
+    // ... (文件名创建逻辑) ...
+    
+    // ... (资源声明) ...
+    unsigned char* recipient_cert_pem = NULL;
+    unsigned char recipient_pk[HSC_MASTER_PUBLIC_KEY_BYTES];
+    
+    if (recipient_pk_file) {
+        // --- 原始密钥模式 ---
+        fprintf(stdout, "
\033[33m[警告] 您正在使用原始公钥模式进行加密。\n       系统不会验证接收者身份，请确保您信任此公钥的来源。\033[0m
\n");
+        size_t pk_len;
+        unsigned char* pk_buf = read_small_file(recipient_pk_file, &pk_len);
+        if (!pk_buf || pk_len != HSC_MASTER_PUBLIC_KEY_BYTES) {
+            fprintf(stderr, "错误: 读取或验证接收者公钥文件 '%s' 失败。\n", recipient_pk_file);
+            free(pk_buf);
+            goto cleanup;
+        }
+        memcpy(recipient_pk, pk_buf, HSC_MASTER_PUBLIC_KEY_BYTES);
+        free(pk_buf);
+    } else {
+        // --- 证书模式 (原有逻辑) ---
+        size_t cert_len;
+        recipient_cert_pem = read_small_file(recipient_cert_file, &cert_len);
+        if (!recipient_cert_pem) { goto cleanup; }
+    
+        if (hsc_extract_public_key_from_cert((const char*)recipient_cert_pem, recipient_pk) != HSC_OK) {
+            fprintf(stderr, "错误: 无法从接收者证书 '%s' 中提取公钥。\n", recipient_cert_file);
+            goto cleanup;
+        }
+    }
+    
+    // 后续的加密流程 (加载发送者私钥、封装会话密钥等) 完全相同，因为它们都使用 recipient_pk
+    // ...
+}

```
您需要对`handle_hybrid_decrypt`函数进行类似的修改，增加`--sender-pk-file`选项，并处理其与`--from`（证书文件）的互斥逻辑。

#### **步骤 4: 更新文档 (`README.md`)**

这是确保用户能安全、正确使用新功能的最后一步，也是最重要的一步。

1.  **更新 "用法指南" (`5.1. As a Command-Line Tool`):**
    在Alice加密文件的步骤中，增加一个“原始密钥模式”的备选方案。

    ```markdown
    6.  **(Alice) Encrypt a file for Bob:**

        *Alice now has two options:*

        **Option A: Certificate-Based (Recommended for most cases)**
        *Alice encrypts `secret.txt` using her private key (`alice.key`) and Bob's verified certificate (`bob.pem`). This provides strong identity assurance.*
        ```bash
        echo "This is top secret information." > secret.txt
        ./bin/hsc_cli encrypt secret.txt --to bob.pem --from alice.key
        ```

        **Option B: Direct Key Mode (Advanced - for pre-trusted keys)**
        *If Alice has obtained Bob's public key (`bob.pub`) through a secure, trusted channel, she can encrypt directly to it, bypassing certificate checks.*
        ```bash
        echo "This is top secret information." > secret.txt
        ./bin/hsc_cli encrypt secret.txt --recipient-pk-file bob.pub --from alice.key
        ```
        *This creates `secret.txt.hsc`. Alice can now send `secret.txt.hsc` to Bob.*
    ```
    对Bob的解密步骤也进行类似的补充。

2.  **新增 "高级主题: 加密模式对比" 章节:**
    在`README.md`中增加一个新章节，详细解释两种模式的差异。

    ```markdown
    ## 8. Advanced Topics: Comparing Encryption Modes

    Oracipher Core provides two distinct workflows for hybrid encryption, each with different security guarantees. Choosing the right mode is critical.

    ### Certificate-Based Workflow (Default & Recommended)

    *   **How it works:** Uses X.509 certificates to bind a user's identity (e.g., `bob@example.com`) to their public key.
    *   **Security Guarantees:**
        *   **Authentication:** Cryptographically verifies that the public key belongs to the intended recipient.
        *   **Integrity:** Ensures the certificate has not been tampered with.
        *   **Revocation Checking:** Actively checks via OCSP if the certificate has been revoked by the Certificate Authority.
    *   **When to use:** In any scenario where the sender and receiver do not have a pre-existing, highly secure channel to exchange public keys. This is the standard for most internet-based communication.

    ### Direct Key (Raw) Workflow (Advanced)

    *   **How it works:** Bypasses all PKI and certificate logic, encrypting directly to a raw public key file.
    *   **Security Guarantees:**
        *   Provides the same level of **confidentiality** and **integrity** for the encrypted data itself as the certificate mode.
    *   **Security Trade-off:**
        *   **NO AUTHENTICATION:** This mode **DOES NOT** verify the identity of the key's owner. The user is solely responsible for ensuring the authenticity of the public key they are using. Using an incorrect or malicious public key will lead to data being encrypted for the wrong party.
    *   **When to use:** Only in closed systems or specific protocols where public keys have been exchanged and verified through a separate, trusted, out-of-band mechanism (e.g., keys baked into a secure device's firmware, or verified in person).
    ```

---

### **第三部分：委员会结论**

委员会批准此项功能增强提案。以上方案在提供了用户所需灵活性的同时，通过**明确的API隔离、强制的命令行逻辑检查和详尽的文档说明**，最大程度地规避了新模式可能带来的误用风险。

我们建议您严格按照此方案进行修改。完成后，委员会将乐于对新的实现进行一次增量审查。我们建议您严格按照此方案进行修改。完成后，委员会将乐于对新的实现进行一次增量审查。