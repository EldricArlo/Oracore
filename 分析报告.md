[中优先级] 加固 CLI 的输入处理 (涉及 cli.c)
任务： 为所有使用 snprintf 构造路径的地方添加返回值检查，以防止路径截断。
理由： 提高程序在处理超长输入时的健壮性，防止非预期的文件操作。
[中优先级] 区分二进制与文本文件读取 (涉及 cli.c)
任务： 重构 read_file_bytes，移除添加 \0 的操作，使其成为一个纯粹的二进制读取函数。并为需要读取文本的场景（如证书）提供一个独立的辅助函数。
理由： 提高代码的清晰度和正确性，避免职责混淆。


[问题点] 细微的头文件依赖
[问题描述] pki_handler.h 为了使用 master_key_pair 结构体而包含了整个 crypto_client.h 头文件。
[风险分析] 这是一个非常微小的问题，但在大型项目中，这种做法会不必要地增加模块间的编译依赖，延长编译时间。它暴露了比所需更多的 crypto_client 内部细节给 pki 模块。
[修复建议] 为了实现更彻底的解耦，可以考虑以下两种方案之一：
前向声明 (Forward Declaration): 如果 pki_handler.h 中的函数只使用了 master_key_pair 的指针，可以在 pki_handler.h 中使用 typedef struct master_key_pair_t master_key_pair; 进行前向声明，并在 pki_handler.c 中再包含 crypto_client.h。
结构体定义分离： 将 master_key_pair 等共享数据结构的定义移至一个更基础的头文件（例如 common/types.h）中，供 core_crypto 和 pki 共同包含。

[问题点] 命令行工具中的内存泄漏
[问题描述] 在 cli.c 的 handle_gen_csr 和 handle_hybrid_decrypt 等函数中，当 read_file_bytes 调用失败时，程序会直接返回，而此前已通过 secure_alloc 分配的内存（如 mkp.sk）未被释放。
[风险分析] 这会导致内存泄漏。虽然在短暂运行的命令行工具中影响有限，但这在库或长时间运行的服务中是严重问题。它也反映了错误处理路径不够完备。
[修复建议] 在所有错误返回路径上，确保已分配的资源被正确清理。使用 goto cleanup 模式可以很好地解决这个问题。
代码示例 (cli.c: handle_gen_csr):
```code
C
// --- 问题代码 ---
unsigned char* sk_from_file = read_file_bytes(priv_path, &sk_len);
if (!sk_from_file || sk_len != MASTER_SECRET_KEY_BYTES) {
    fprintf(stderr, "错误: 读取或验证私钥失败。\n");
    secure_free(mkp.sk); // 泄漏点：mkp.sk 已分配但未释放
    free(sk_from_file); 
    return 1;
}

// --- 修复建议 ---
int ret = 1; // 默认返回错误
master_key_pair mkp;
mkp.sk = NULL; // 初始化为 NULL
unsigned char* sk_from_file = NULL;
char* csr_pem = NULL;

mkp.sk = secure_alloc(MASTER_SECRET_KEY_BYTES);
if (!mkp.sk) { /* ... 错误处理 ... */ goto cleanup; }

size_t sk_len;
sk_from_file = read_file_bytes(priv_path, &sk_len);
if (!sk_from_file || sk_len != MASTER_SECRET_KEY_BYTES) {
    fprintf(stderr, "错误: 读取或验证私钥失败。\n");
    goto cleanup; // 跳转到统一的清理逻辑
}
// ... 正常逻辑 ...
ret = 0; // 成功

cleanup:
    if (mkp.sk) free_master_key_pair(&mkp);
    if (sk_from_file) {
        secure_zero_memory(sk_from_file, sk_len);
        free(sk_from_file);
    }
    if (csr_pem) free_csr_pem(csr_pem);
    return ret;
```

[问题点] 从 libsodium 向 OpenSSL 传递密钥时的不明确假设
[问题描述] 在 pki_handler.c 的 generate_csr 函数中，使用了以下代码将 libsodium 的 Ed25519 私钥加载到 OpenSSL 中：
code
C
pkey = EVP_PKEY_new_raw_private_key(EVP_PKEY_ED25519, NULL, mkp->sk, crypto_sign_SEEDBYTES);
libsodium 的 crypto_sign_SECRETKEYBYTES (64字节) 包含了 32 字节的种子（私钥）和 32 字节的公钥。而 EVP_PKEY_new_raw_private_key 期望的是 32 字节的种子。这段代码能工作，仅仅是因为种子恰好是 mkp->sk 的前 32 字节。
[风险分析] 这段代码依赖于 libsodium 内部的密钥格式，这是一个未公开的实现细节。如果未来 libsodium 更改其 sk 的内部布局，这段代码将以一种难以调试的方式静默失败，甚至可能引入安全漏洞。代码应始终基于库的公共 API 而非内部实现。
[修复建议] 使用 libsodium 提供的专用函数 crypto_sign_ed25519_sk_to_seed 来显式地从密钥中提取种子，然后再将其传递给 OpenSSL。
代码示例 (pki_handler.c):
```code
C
// --- 修复建议 ---
#include <sodium.h> // 确保包含了完整的头文件

// ...
EVP_PKEY* pkey = NULL;
X509_REQ* req = NULL;
BIO* bio = NULL;

// 显式地从64字节的私钥中提取32字节的种子
unsigned char private_seed[crypto_sign_SEEDBYTES];
crypto_sign_ed25519_sk_to_seed(private_seed, mkp->sk);

pkey = EVP_PKEY_new_raw_private_key(EVP_PKEY_ED25519, NULL, private_seed, sizeof(private_seed));

// 立即擦除栈上的种子副本
secure_zero_memory(private_seed, sizeof(private_seed));

if (!pkey) {
    LOG_PKI_ERROR("EVP_PKEY_new_raw_private_key failed.");
    goto cleanup;
}
// ...
```

[问题点] 脆弱的文件名字符串操作
[问题描述] 在 cli.c 的 handle_gen_csr 和 handle_hybrid_decrypt 函数中，构造输出文件名的逻辑使用了 strncpy 和 strncat，这在处理边界条件时非常容易出错。
[风险分析] strncpy 在源字符串过长时可能不会添加空终止符 \0，导致后续的 strncat 行为未定义，可能造成缓冲区溢出。整个逻辑比较复杂，难以一眼看出其正确性。
[修复建议] 重构此逻辑，采用更安全、更清晰的方式来替换文件扩展名。一个健壮的方法是先复制整个路径，然后安全地找到并修改扩展名。
代码示例 (cli.c: handle_gen_csr):
code
```C
// --- 问题代码 ---
// char csr_path[260];
// const char* dot = strrchr(priv_path, '.');
// if(dot) {
//     snprintf(csr_path, dot - priv_path + 1, "%s", priv_path);
// } else {
//     strncpy(csr_path, priv_path, sizeof(csr_path) - 5);
// }
// strncat(csr_path, ".csr", sizeof(csr_path) - strlen(csr_path) - 1);

// --- 修复建议 ---
char csr_path[260];

// 步骤1: 安全地复制基础文件名
strncpy(csr_path, priv_path, sizeof(csr_path) - 1);
csr_path[sizeof(csr_path) - 1] = '\0'; // 确保 null 结尾

// 步骤2: 查找并替换扩展名
char* dot = strrchr(csr_path, '.');
// 如果没有点，或者点后面还有斜杠（如 ".bashrc"），则视为无扩展名
char* slash = strrchr(csr_path, '/');
if (dot && (!slash || dot > slash)) {
    // 找到了扩展名，用 .csr 替换
    strcpy(dot, ".csr");
} else {
    // 没有找到扩展名，追加 .csr
    strncat(csr_path, ".csr", sizeof(csr_path) - strlen(csr_path) - 1);
}
```

[P0 - 关键] 修复密钥传递逻辑:
任务: 修改 pki_handler.c，使用 crypto_sign_ed25519_sk_to_seed 来显式提取种子，再传递给 OpenSSL。
理由: 消除对外部库内部实现的危险依赖，确保长期的正确性和安全性。


[P1 - 高] 修复内存泄漏:
任务: 审查 cli.c 中的所有函数，确保在任何错误返回路径上，所有已分配的资源（特别是通过 secure_alloc 分配的）都被正确释放。
理由: 保证资源管理的健壮性，是编写可靠C程序的基本要求。


[P2 - 中] 加固字符串操作:
任务: 重构 cli.c 中构造输出文件名的逻辑，使用更安全、更清晰的字符串处理函数和模式。
理由: 消除潜在的缓冲区溢出风险，提升代码的健壮性和可读性。

[P3 - 低] 优化头文件依赖:
任务: 考虑通过前向声明或分离类型定义的方式，解除 pki_handler.h 对 crypto_client.h 的直接包含。
理由: 纯粹的架构优化，可以改善大型项目的编译依赖关系。