<div align="center">
  <img src="./src/media/icon-256.png" alt="Oracipher Icon" width="128">
  <h1 style="border-bottom: none;">Oracipher Core</h1>

# 高セキュリティハイブリッド暗号化カーネルライブラリ

| Build & Test | License | Language | Dependencies |
| :---: | :---: | :---: | :---: |
| ![Build Status](https://img.shields.io/badge/tests-passing-brightgreen) | ![License](https://img.shields.io/badge/license-Dual--Licensed-blue) | ![Language](https://img.shields.io/badge/language-C11-purple) | ![Libsodium](https://img.shields.io/badge/libsodium-v1.0.18+-brightgreen) ![OpenSSL](https://img.shields.io/badge/OpenSSL-v3.0+-0075A8) ![Libcurl](https://img.shields.io/badge/libcurl-v7.68+-E5522D) |

</div>

---

### **目次**
1.  [プロジェクトのビジョンと基本原則](#1-プロジェクトのビジョンと基本原則)
2.  [主な特徴](#2-主な特徴)
3.  [プロジェクト構造](#3-プロジェクト構造)
4.  [クイックスタート](#4-クイックスタート)
    *   [4.1 依存関係](#41-依存関係)
    *   [4.2 コンパイルとテスト](#42-コンパイルとテスト)
5.  [使用ガイド](#5-使用ガイド)
    *   [5.1 コマンドラインツールとしての使用 (`hsc_cli` & `test_ca_util`)](#51-コマンドラインツールとしての使用hsc_cli--test_ca_util)
    *   [5.2 プロジェクトでライブラリとして使用する](#52-プロジェクトでライブラリとして使用する)
6.  [技術アーキテクチャの詳細](#6-技術アーキテクチャの詳細)
7.  [高度な設定：環境変数によるセキュリティ強化](#7-高度な設定環境変数によるセキュリティ強化)
8.  [高度なトピック：暗号化モードの比較](#8-高度なトピック暗号化モードの比較)
9.  [コアAPIリファレンス (`include/hsc_kernel.h`)](#9-コアapiリファレンスincludehsc_kernelh)
10. [貢献](#10-貢献)
11. [証明書について](#11-証明書について)
12. [ライセンス - デュアルライセンスモデル](#12-ライセンス---デュアルライセンスモデル)

---

## 1. プロジェクトのビジョンと基本原則

このプロジェクトは、セキュリティを核とし、C11標準で実装された高度なハイブリッド暗号化カーネルライブラリです。業界をリードする暗号ライブラリ（**libsodium**, **OpenSSL**, **libcurl**）を堅牢で信頼性が高く、使いやすいエンドツーエンドの暗号化ソリューションに統合する方法を示す、実戦で検証済みの青写真を提供することを目的としています。

私たちの設計は、以下の基本的なセキュリティ原則に従っています：

*   **検証済みの現代暗号を選択：** 独自の暗号アルゴリズムは決して開発しません。コミュニティに広く認められ、サイドチャネル攻撃に耐性のある現代の暗号プリミティブのみを使用します。
*   **多層防御：** セキュリティは単一の層に依存しません。メモリ管理、API設計、プロトコルフローなど、複数のレベルで保護を実装しています。
*   **セキュアなデフォルト設定と「フェイルクローズ」ポリシー：** システムのデフォルトの動作は安全でなければなりません。不確実な状態（例：証明書の失効状態を検証できない）に直面した場合、システムは処理を続行するのではなく、失敗を選択して操作を終了（フェイルクローズ）しなければなりません。
*   **機密データの露出を最小化：** 秘密鍵などの重要なデータがメモリ内に存在するライフサイクル、スコープ、滞留時間を厳密に制御し、絶対に必要な最小限に抑えます。

## 2. 主な特徴

*   **堅牢なハイブリッド暗号化モデル：**
    *   **対称暗号：** **XChaCha20-Poly1305** に基づき、AEADストリーム暗号（大規模データブロック向け）とワンショットAEAD暗号（小規模データブロック向け）を提供します。
    *   **非対称暗号：** **X25519**（Curve2519ベース）を使用して対称セッションキーを鍵カプセル化し、意図した受信者のみが復号できるようにします。

*   **現代的な暗号プリミティブスタック：**
    *   **鍵導出：** パスワードハッシュコンペティションの勝者である **Argon2id** を採用し、GPUやASICによるクラッキングの試みに効果的に対抗します。
    *   **デジタル署名：** **Ed25519** を利用して、高速かつ高セキュリティのデジタル署名機能を提供します。
    *   **鍵の統一：** Ed25519キーを安全にX25519キーに変換できる特性を巧みに利用し、単一のマスターキーペアで署名と暗号化の両方のニーズを満たすことを可能にします。

*   **完全な公開鍵基盤 (PKI) サポート：**
    *   **証明書のライフサイクル：** X.509 v3標準に準拠した証明書署名要求 (CSR) の生成をサポートします。
    *   **厳格な証明書検証：** 信頼チェーン、有効期間、サブジェクトの一致を含む、標準化された証明書検証プロセスを提供します。
    *   **強制的な失効確認 (OCSP)：** 厳格なオンライン証明書ステータスプロトコル (OCSP) チェックを内蔵し、「フェイルクローズ」ポリシーを採用しています。証明書の有効性が確認できない場合、操作は直ちに中止されます。

*   **盤石なメモリ安全性：**
    *   公開APIを通じて`libsodium`のセキュアメモリ関数を公開し、クライアントが機密データ（セッションキーなど）を安全に取り扱えるようにします。
    *   **[セキュリティに関するドキュメント]** すべての内部秘密鍵**およびその他の重要な秘密情報（鍵のシード、中間ハッシュ値など）**はロックされたメモリに保存され、**OSによるディスクへのスワップを防ぎ**、解放前に安全にゼロクリアされます。サードパーティライブラリ（OpenSSLなど）とのデータ境界は慎重に管理されています。機密データが標準メモリ領域に渡される必要がある場合（例：`generate_csr`でシードをOpenSSLに渡す際）、このライブラリは多層防御技術（使用後すぐにメモリバッファをクリアするなど）を用いて固有のリスクを軽減します。これは、セキュアメモリを意識しないライブラリと対話する際のベストプラクティスを示しています。

*   **高品質なエンジニアリング実践：**
    *   **明確なAPI境界：** 単一の公開ヘッダーファイル `hsc_kernel.h` を提供し、不透明ポインタを使用してすべての内部実装詳細をカプセル化することで、高い凝集度と低い結合度を実現します。
    *   **包括的なテストスイート：** コア暗号、PKI、高レベルAPI機能をカバーする単体テストと統合テストのセットを含み、コードの正確性と信頼性を保証します。
    *   **分離されたロギングシステム：** コールバックベースのロギングメカニズムを実装し、クライアントアプリケーションがログメッセージの表示方法と場所を完全に制御できるようにすることで、ライブラリをあらゆる環境に適応させます。
    *   **詳細なドキュメントとサンプル：** 詳細な `README.md`、すぐに実行できるデモプログラム、そして強力なコマンドラインツールを提供します。

## 3. プロジェクト構造

プロジェクトは、関心事の分離を実現するために、明確で階層的なディレクトリ構造を採用しています。

```.
├── include/
│   └── hsc_kernel.h      # [コア] 唯一の公開APIヘッダーファイル
├── src/                  # ソースコード
│   ├── common/           # 共通内部モジュール (セキュアメモリ, ロギング)
│   ├── core_crypto/      # コア暗号内部モジュール (libsodium ラッパー)
│   ├── pki/              # PKI 内部モジュール (OpenSSL, libcurl ラッパー)
│   ├── hsc_kernel.c      # [コア] 公開APIの実装
│   ├── main.c            # API使用例: エンドツーエンドのデモプログラム
│   └── cli.c             # API使用例: 強力なコマンドラインツール
├── tests/                # 単体テストとテストユーティリティ
│   ├── test_*.c          # 各モジュールの単体テスト
│   ├── test_api_integration.c # [新規] 高レベルAPIのエンドツーエンドテスト
│   ├── test_helpers.h/.c # テストヘルパー関数 (CA生成, 署名)
│   └── test_ca_util.c    # 独立したテストCAユーティリティのソースコード
├── Makefile              # ビルドとタスク管理スクリプト
└── README.md             # 本プロジェクトのドキュメント
```

## 4. クイックスタート

### 4.1 依存関係

*   **ビルドツール:** `make`
*   **Cコンパイラ:** `gcc` または `clang` (C11と`-Werror`をサポート)
*   **libsodium:** (`libsodium-dev`)
*   **OpenSSL:** **v3.0** 以降を推奨 (`libssl-dev`)
*   **libcurl:** (`libcurl4-openssl-dev`)

**主要システムでのインストール:**

*   **Debian/Ubuntu:**
    ```bash
    sudo apt-get update
    sudo apt-get install build-essential libsodium-dev libssl-dev libcurl4-openssl-dev
    ```
*   **Fedora/RHEL/CentOS:**
    ```bash
    sudo dnf install gcc make libsodium-devel openssl-devel libcurl-devel
    ```
*   **macOS (Homebrewを使用):**
    ```bash
    brew install libsodium openssl@3 curl
    ```

### 4.2 コンパイルとテスト

プロジェクトは高い移植性を目指して設計されており、プラットフォーム固有のハードコードされたパスを避けることで、サポートされているすべてのシステムで正しくビルドおよび実行されることを保証します。

1.  **すべてのターゲットをコンパイル (ライブラリ, デモ, CLI, テスト):**
    ```bash
    make all
    ```

2.  **包括的なテストスイートを実行 (重要なステップ):**
    ```bash
    make run-tests
    ```
    > **OCSPテストの期待される動作に関する重要事項**
    >
    > `test_pki_verification` 内の一つのテストケースでは、意図的に存在しないローカルOCSPサーバー（`http://127.0.0.1:8888`）を指す証明書を検証します。ネットワークリクエストは失敗し、その時点で `hsc_verify_user_certificate` 関数は**必ず** `-12` (すなわち `HSC_ERROR_CERT_REVOKED_OR_OCSP_FAILED` のエラーコード) を返さなければなりません。テストプログラムはこの特定の戻り値をアサートします。
    >
    > この「失敗」は、**期待される正しい動作**です。なぜなら、私たちの「フェイルクローズ」セキュリティポリシーが正しく実装されていることを完璧に証明しているからです：**何らかの理由で証明書の失効状態を確認できない場合、その証明書は無効として扱われます。**

3.  **デモプログラムを実行:**
    ```bash
    ./bin/hsc_demo
    ```

4.  **コマンドラインツールを試す:**
    ```bash
    ./bin/hsc_cli
    ```

5.  **ビルドファイルをクリーンアップ:**
    ```bash
    make clean
    ```

## 5. 使用ガイド

### 5.1 コマンドラインツールとしての使用 (`hsc_cli` & `test_ca_util`)

このセクションでは、二人のユーザー（アリスとボブ）が提供されたコマンドラインツールを使用して安全なファイル交換を行う、完全で自己完結したワークフローを説明します。

**ツールの役割:**
*   `./bin/test_ca_util`: ルート証明書の生成とユーザー証明書の署名を行う認証局(CA)をシミュレートするヘルパーユーティリティ。
*   `./bin/hsc_cli`: 鍵生成、CSR作成、証明書検証、ファイルの暗号化・復号を行うコアクライアントツール。

**完全なワークフロー例：アリスがファイルを暗号化し、ボブに安全に送信する**

1.  **(セットアップ) テスト用の認証局 (CA) を作成:**
    *`test_ca_util` を使用して、ルートCAの鍵と自己署名証明書を生成します。*
    ```bash
    ./bin/test_ca_util gen-ca ca.key ca.pem
    ```

2.  **(アリスとボブ) それぞれのマスターキーペアを生成:**
    ```bash
    ./bin/hsc_cli gen-keypair alice
    ./bin/hsc_cli gen-keypair bob
    ```
    *これにより `alice.key`, `alice.pub`, `bob.key`, `bob.pub` が作成されます。*

3.  **(アリスとボブ) 証明書署名要求 (CSR) を生成:**
    ```bash
    ./bin/hsc_cli gen-csr alice.key "alice@example.com"
    ./bin/hsc_cli gen-csr bob.key "bob@example.com"
    ```
    *これにより `alice.csr` と `bob.csr` が作成されます。*

4.  **(CA) CSRに署名して証明書を発行:**
    *CAは自身の秘密鍵 (`ca.key`) と証明書 (`ca.pem`) を使用してCSRに署名します。*
    ```bash
    ./bin/test_ca_util sign alice.csr ca.key ca.pem alice.pem
    ./bin/test_ca_util sign bob.csr ca.key ca.pem bob.pem
    ```
    *これでアリスとボブは公式の証明書 `alice.pem` と `bob.pem` を手に入れました。*

5.  **(アリス) 送信する前にボブの証明書を検証:**
    *アリスは信頼できるCA証明書 (`ca.pem`) を使用してボブの身元を検証します。これは彼の証明書を信頼する前の重要なステップです。*
    ```bash
    ./bin/hsc_cli verify-cert bob.pem --ca ca.pem --user "bob@example.com"
    ```

6.  **(アリス) ボブのためにファイルを暗号化:**
    *アリスにはいくつかの選択肢があります:*

    **オプションA：証明書ベースで検証あり (セキュアなデフォルト＆推奨)**
    > これは標準的で安全な操作方法です。ツールは、暗号化の前にボブの証明書の完全かつ厳格な検証を行うために、アリスにCA証明書と期待されるユーザー名の提供を**要求**します。
    ```bash
    echo "This is top secret information." > secret.txt
    ./bin/hsc_cli encrypt secret.txt --to bob.pem --from alice.key --ca ca.pem --user "bob@example.com"
    ```

    **オプションB：証明書ベースで検証なし (危険 - 専門家のみ)**
    > アリスが証明書の正当性を絶対に確信しており、検証をスキップしたい場合は、明示的に `--no-verify` フラグを使用する必要があります。**これは推奨されません。**
    ```bash
    # 細心の注意を払って使用してください！
    ./bin/hsc_cli encrypt secret.txt --to bob.pem --from alice.key --no-verify
    ```

    **オプションC：ダイレクトキーモード (高度 - 事前信頼された鍵向け)**
    *アリスが安全で信頼できるチャネルを通じて既にボブの公開鍵 (`bob.pub`) を入手している場合、証明書のロジックをすべてバイパスして直接暗号化できます。*
    ```bash
    ./bin/hsc_cli encrypt secret.txt --recipient-pk-file bob.pub --from alice.key
    ```
    *すべてのオプションで `secret.txt.hsc` が作成されます。アリスは `secret.txt.hsc` と彼女の証明書 `alice.pem` をボブに送信できます。*

7.  **(ボブ) 受信したファイルを復号:**
    *ボブは自身の秘密鍵 (`bob.key`) を使用してファイルを復号します。アリスがどのように暗号化したかによって、彼女の証明書 (`alice.pem`) または生の公開鍵 (`alice.pub`) が必要になります。*

    **アリスがオプションAまたはB（証明書）を使用した場合:**
    ```bash
    ./bin/hsc_cli decrypt secret.txt.hsc --to bob.key --from alice.pem
    ```

    **アリスがオプションC（ダイレクトキー）を使用した場合:**
    ```bash
    ./bin/hsc_cli decrypt secret.txt.hsc --to bob.key --sender-pk-file alice.pub
    ```
    *どちらのコマンドも `secret.txt.decrypted` を生成します。*
    ```bash
    cat secret.txt.decrypted
    ```

### 5.2 プロジェクトでライブラリとして使用する

`src/main.c` は優れた統合例です。典型的なAPI呼び出しフローは以下の通りです：

1.  **グローバル初期化とログ設定:** 起動時に `hsc_init()` を呼び出し、ログコールバックを登録します。
    ```c
    #include "hsc_kernel.h"
    #include <stdio.h>

    // アプリケーション用のシンプルなロギング関数を定義
    void my_app_logger(int level, const char* message) {
        // 例：エラーはstderrに、情報はstdoutに出力
        if (level >= 2) { // 2 = ERROR
            fprintf(stderr, "[HSC_LIB_ERROR] %s\n", message);
        } else {
            printf("[HSC_LIB_INFO] %s\n", message);
        }
    }

    int main() {
        if (hsc_init() != HSC_OK) {
            // 致命的なエラーを処理
        }
        // ロギング関数をライブラリに登録
        hsc_set_log_callback(my_app_logger);

        // ... あなたのコード ...
        hsc_cleanup();
        return 0;
    }
    ```

2.  **送信者 (アリス) がデータを暗号化:**
    ```c
    // 1. ワンタイムのセッションキーを生成
    unsigned char session_key[HSC_SESSION_KEY_BYTES];
    hsc_random_bytes(session_key, sizeof(session_key));

    // 2. セッションキーでデータをAEAD暗号化（小データ向け）
    const char* message = "Secret message";
    // ... (暗号化ロジックはサンプルと同じ) ...

    // 3. 受信者 (ボブ) の証明書を検証
    if (hsc_verify_user_certificate(bob_cert_pem, ca_pem, "bob@example.com") != HSC_OK) {
        // 証明書は無効、中断！ライブラリはコールバック経由で詳細をログに記録します。
    }

    // 4. ボブの証明書から公開鍵を抽出
    unsigned char bob_pk[HSC_MASTER_PUBLIC_KEY_BYTES];
    if (hsc_extract_public_key_from_cert(bob_cert_pem, bob_pk) != HSC_OK) {
        // 抽出エラーを処理
    }

    // 5. セッションキーをカプセル化
    // ... (カプセル化ロジックはサンプルと同じ) ...
    ```

3.  **受信者 (ボブ) がデータを復号:**
    *復号ロジックは同じですが、デカプセル化またはAEAD復号中の内部エラーは、`stderr` を直接汚染する代わりに、登録した `my_app_logger` コールバックを通じて報告されるようになります。*

## 6. 技術アーキテクチャの詳細

このプロジェクトの中核は、非対称暗号と対称暗号の利点を組み合わせて、安全かつ効率的なデータ転送を実現するハイブリッド暗号化モデルです。

**データフローと鍵の関係図:**

```
送信者 (ALICE)                                           受信者 (BOB)
========================================================================
[ 平文 ] ------> 生成 [ セッションキー ]
                   |          |
(対称暗号化) <------'          '-> (非対称カプセル化) 使用: ボブの公開鍵, アリスの秘密鍵
     |                                          |
[ 暗号化データ ]                     [ カプセル化されたセッションキー ]
     |                                          |
     '--------------------.  .------------------'
                          |  |
                          v  v
                     [ データパケット ]
                          |
   ==================>  ネットワーク/ファイル経由  =================>
                          |
                     [ データパケット ]
                          |  |
           .--------------'  '----------------.
           |                                  |
[ カプセル化されたセッションキー ]         [ 暗号化データ ]
           |                                  |
           v                                  |
(非対称デカプセル化) 使用: ボブの秘密鍵, アリスの公開鍵
           |                                  |
           v                                  |
      [ 回復されたセッションキー ] <----$----' (対称復号)
           |
           v
      [ 平文 ]
```

## 7. 高度な設定：環境変数によるセキュリティ強化

将来のハードウェアやセキュリティ要件にコードを変更することなく適応するため、このプロジェクトは環境変数を通じて鍵導出関数 (Argon2id) の計算コストを**増加**させることをサポートしています。

*   **`HSC_ARGON2_OPSLIMIT`**: Argon2idの操作回数（計算ラウンド数）を設定します。
*   **`HSC_ARGON2_MEMLIMIT`**: Argon2idのメモリ使用量をバイト単位で設定します。

**重要なセキュリティノート:** この機能は**セキュリティパラメータを強化するためにのみ使用できます**。環境変数に設定された値がプロジェクトに組み込まれた最小セキュリティベースラインよりも低い場合、プログラムはこれらの安全でない値を自動的に無視し、組み込みの最小値を強制します。

**使用例:**

```bash
# 例：操作制限を10に、メモリ制限を512MBに増加させる。
# 注意：HSC_ARGON2_MEMLIMIT にはバイト単位の値が必要です。
# 512 * 1024 * 1024 = 536870912 バイト。
export HSC_ARGON2_OPSLIMIT=10
export HSC_ARGON2_MEMLIMIT=536870912

# これらの変数が設定されたシェルでプログラムを実行すると、自動的にこれらのより強力なパラメータが使用されます。
./bin/hsc_cli gen-keypair my_strong_key
```

## 8. 高度なトピック：暗号化モードの比較

Oracipher Coreは、それぞれ異なるセキュリティ保証を持つ2つの明確に異なるハイブリッド暗号化ワークフローを提供します。正しいものを選択することが重要です。

### 証明書ベースのワークフロー (デフォルト＆推奨)

*   **仕組み:** X.509証明書を使用して、ユーザーのアイデンティティ（例：`bob@example.com`）をその公開鍵に結びつけます。
*   **セキュリティ保証:**
    *   **認証:** 公開鍵が本当に意図した受信者のものであることを暗号学的に検証します。
    *   **完全性:** 証明書が改ざんされていないことを保証します。
    *   **失効確認:** OCSPを介して、証明書が発行機関によって失効されていないかを積極的に確認します。
*   **使用場面:** 送信者と受信者が公開鍵を交換するための既存の高度に安全なチャネルを持っていないあらゆるシナリオ。これはほとんどのインターネットベースの通信の標準です。

### ダイレクトキー (Raw) ワークフロー (高度)

*   **仕組み:** すべてのPKIと証明書のロジックをバイパスし、生の公開鍵ファイルに直接暗号化します。
*   **セキュリティ保証:**
    *   暗号化されたデータ自体に対して、証明書モードと同じレベルの**機密性**と**完全性**を提供します。
*   **セキュリティのトレードオフ:**
    *   **認証なし:** このモードは鍵の所有者の身元を**検証しません**。使用している公開鍵の正当性を保証するのは、ユーザー自身の責任です。不正確または悪意のある公開鍵を使用すると、データが間違った相手のために暗号化されることになります。
*   **使用場面:** 公開鍵が独立した信頼できるアウトオブバンドメカニズム（例：安全なデバイスのファームウェアに鍵が焼き付けられている、または直接会って検証する）を通じて交換および検証されている、閉じたシステムまたは特定のプロトコルでのみ使用します。

## 9. コアAPIリファレンス (`include/hsc_kernel.h`)

### 初期化とクリーンアップ
| 関数 | 説明 |
| :--- | :--- |
| `int hsc_init()` | **(最初に呼び出す必要があります)** ライブラリ全体を初期化します。 |
| `void hsc_cleanup()` | プログラム終了前に呼び出して、グローバルリソースを解放します。 |

### 鍵管理
| 関数 | 説明 |
| :--- | :--- |
| `hsc_master_key_pair* hsc_generate_master_key_pair()` | 新しいマスターキーペアを生成します。 |
| `hsc_master_key_pair* hsc_load_master_key_pair_from_private_key(...)` | ファイルから秘密鍵を読み込みます。 |
| `int hsc_save_master_key_pair(...)` | キーペアをファイルに保存します。 |
| `void hsc_free_master_key_pair(hsc_master_key_pair** kp)` | マスターキーペアを安全に解放します。 |
| `int hsc_get_master_public_key(const hsc_master_key_pair* kp, ...)` | **[新規]** キーペアハンドルから生の公開鍵を抽出します。 |

### PKIと証明書
| 関数 | 説明 |
| :--- | :--- |
| `int hsc_generate_csr(...)` | PEM形式の証明書署名要求 (CSR) を生成します。 |
| `int hsc_verify_user_certificate(...)` | **(コア)** 完全な証明書検証 (信頼チェーン, 有効期間, サブジェクト, OCSP) を実行します。 |
| `int hsc_extract_public_key_from_cert(...)` | 検証済みの証明書から公開鍵を抽出します。 |

### 鍵カプセル化 (非対称)
| 関数 | 説明 |
| :--- | :--- |
| `int hsc_encapsulate_session_key(...)` | 受信者の公開鍵を使用してセッションキーを暗号化します。 |
| `int hsc_decapsulate_session_key(...)` | 受信者の秘密鍵を使用してセッションキーを復号します。 |

### ストリーム暗号化 (対称, 大規模ファイル向け)
| 関数 | 説明 |
| :--- | :--- |
| `hsc_crypto_stream_state* hsc_crypto_stream_state_new_push(...)` | 暗号化ストリーム状態オブジェクトを作成します。 |
| `hsc_crypto_stream_state* hsc_crypto_stream_state_new_pull(...)` | 復号ストリーム状態オブジェクトを作成します。 |
| `int hsc_crypto_stream_push(...)` | ストリーム内でデータチャンクを暗号化します。 |
| `int hsc_crypto_stream_pull(...)` | ストリーム内でデータチャンクを復号します。 |
| `void hsc_crypto_stream_state_free(hsc_crypto_stream_state** state)` | ストリーム状態オブジェクトを解放します。 |
| `int hsc_hybrid_encrypt_stream_raw(...)` | 生の公開鍵を使用してファイルの完全なハイブリッド暗号化を実行します。 |
| `int hsc_hybrid_decrypt_stream_raw(...)` | 生の公開鍵を使用してファイルの完全なハイブリッド復号を実行します。 |

### データ暗号化 (対称, 小規模データ向け)
| 関数 | 説明 |
| :--- | :--- |
| `int hsc_aead_encrypt(...)` | AEADを使用して**小さなデータチャンク**の認証付き暗号化を実行します。 |
| `int hsc_aead_decrypt(...)` | `hsc_aead_encrypt` で暗号化されたデータを復号し検証します。 |

### セキュアメモリ
| 関数 | 説明 |
| :--- | :--- |
| `void* hsc_secure_alloc(size_t size)` | 保護され、スワップ不可能なメモリブロックを割り当てます。 |
| `void hsc_secure_free(void* ptr)` | 保護されたメモリブロックを安全にゼロクリアし、解放します。 |

### ロギング
| 関数 | 説明 |
| :--- | :--- |
| `void hsc_set_log_callback(hsc_log_callback callback)` | **[新規]** すべての内部ライブラリログを処理するためのコールバック関数を登録します。 |

## 10. 貢献

あらゆる形での貢献を歓迎します！バグを見つけたり、機能の提案があったり、ドキュメントを改善したい場合は、遠慮なくプルリクエストを送信するか、Issueを作成してください。

## 11. 証明書について

このプロジェクトは、**X.509 v3** 証明書体系を使用して公開鍵をユーザーID（例：`alice@example.com`）に結びつけ、信頼を確立します。証明書の検証プロセスには、**署名チェーンの検証**、**有効期間の確認**、**サブジェクトIDの検証**、および**失効状態の確認 (OCSP)** が含まれ、これらはすべて厳格な「フェイルクローズ」ポリシーの下で実行されます。

## 12. ライセンス - デュアルライセンスモデル

このプロジェクトは**デュアルライセンス**モデルで配布されています：

### 1. GNU Affero General Public License v3.0 (AGPLv3)
オープンソースプロジェクト、学術研究、個人学習に適しています。変更された、またはネットワーク経由でサービスとして提供される派生物も、その完全なソースコードをAGPLv3の下で公開する必要があります。

### 2. 商用ライセンス
クローズドソースの商用アプリケーション、製品、またはサービスの場合は、商用ライセンスを取得する必要があります。AGPLv3のオープンソース条項に拘束されたくない場合は、商用ライセンスを取得する必要があります。

**商用ライセンスを取得するには、以下にご連絡ください: `eldric520lol@gmail.com`**