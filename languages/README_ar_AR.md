<div dir="rtl" align="center">
  <img src="./src/media/icon-256.png" alt="Oracipher Icon" width="128">
  <h1 style="border-bottom: none;">Oracipher Core</h1>

# مكتبة نواة تشفير هجين عالية الأمان

| البناء والاختبار (Build & Test) | الترخيص (License) | اللغة (Language) | الاعتماديات (Dependencies) |
| :---: | :---: | :---: | :---: |
| ![Build Status](https://img.shields.io/badge/tests-passing-brightgreen) | ![License](https://img.shields.io/badge/license-Dual--Licensed-blue) | ![Language](https://img.shields.io/badge/language-C11-purple) | ![Libsodium](https://img.shields.io/badge/libsodium-v1.0.18+-brightgreen) ![OpenSSL](https://img.shields.io/badge/OpenSSL-v3.0+-0075A8) ![Libcurl](https://img.shields.io/badge/libcurl-v7.68+-E5522D) |

</div>

<div dir="rtl">

---

### **جدول المحتويات**
1.  [رؤية المشروع والمبادئ الأساسية](#1-رؤية-المشروع-والمبادئ-الأساسية)
2.  [الميزات الأساسية](#2-الميزات-الأساسية)
3.  [هيكل المشروع](#3-هيكل-المشروع)
4.  [بداية سريعة](#4-بداية-سريعة)
    *   [4.1 الاعتماديات](#41-الاعتماديات)
    *   [4.2 الترجمة والاختبار](#42-الترجمة-والاختبار)
5.  [دليل الاستخدام](#5-دليل-الاستخدام)
    *   [5.1 الاستخدام كأداة سطر أوامر (`hsc_cli` و `test_ca_util`)](#51-الاستخدام-كأداة-سطر-أوامر-hsc_cli--test_ca_util)
    *   [5.2 الاستخدام كمكتبة في مشروعك](#52-الاستخدام-كمكتبة-في-مشروعك)
6.  [نظرة عميقة: الهيكلية التقنية](#6-نظرة-عميقة-الهيكلية-التقنية)
7.  [التكوين المتقدم: تعزيز الأمان باستخدام متغيرات البيئة](#7-التكوين-المتقدم-تعزيز-الأمان-باستخدام-متغيرات-البيئة)
8.  [موضوع متقدم: مقارنة أوضاع التشفير](#8-موضوع-متقدم-مقارنة-أوضاع-التشفير)
9.  [مرجع واجهة برمجة التطبيقات الأساسية (`include/hsc_kernel.h`)](#9-مرجع-واجهة-برمجة-التطبيقات-الأساسية-includehsc_kernelh)
10. [المساهمة](#10-المساهمة)
11. [ملاحظات حول الشهادات](#11-ملاحظات-حول-الشهادات)
12. [الترخيص - نموذج الترخيص المزدوج](#12-الترخيص---نموذج-الترخيص-المزدوج)

---

## 1. رؤية المشروع والمبادئ الأساسية

هذا المشروع هو مكتبة نواة تشفير هجين متقدمة تتمحور حول الأمان، تم تنفيذها بمعيار C11. يهدف إلى توفير مخطط تم اختباره عمليًا يوضح كيفية دمج مكتبات التشفير الرائدة في الصناعة (**libsodium**, **OpenSSL**, **libcurl**) في حل تشفير شامل وقوي وموثوق وسهل الاستخدام.

يتبع تصميمنا مبادئ الأمان الأساسية التالية:

*   **اختيار تشفير حديث ومُدقق:** لا نبتكر خوارزميات تشفير خاصة بنا أبدًا. نستخدم فقط أساسيات التشفير الحديثة المعترف بها على نطاق واسع من قبل المجتمع والمقاومة لهجمات القنوات الجانبية.
*   **الدفاع في العمق:** لا يعتمد الأمان على طبقة واحدة. نحن نطبق الحماية على مستويات متعددة، بما في ذلك إدارة الذاكرة، تصميم واجهة برمجة التطبيقات، وتدفق البروتوكول.
*   **إعدادات افتراضية آمنة وسياسة "الإغلاق عند الفشل" (Fail-Closed):** يجب أن يكون السلوك الافتراضي للنظام آمنًا. عند مواجهة حالة غير مؤكدة (على سبيل المثال، عدم القدرة على التحقق من حالة إلغاء الشهادة)، يجب على النظام اختيار الفشل وإنهاء العملية (fail-closed) بدلاً من المتابعة.
*   **تقليل تعرض البيانات الحساسة:** نتحكم بشكل صارم في دورة حياة ونطاق ومدة بقاء البيانات الهامة مثل المفاتيح الخاصة في الذاكرة، مع إبقائها عند الحد الأدنى الضروري المطلق.

## 2. الميزات الأساسية

*   **نموذج تشفير هجين قوي:**
    *   **التشفير المتماثل:** يوفر تشفير دفق AEAD (للكتل الكبيرة من البيانات) وتشفير AEAD لمرة واحدة (للكتل الصغيرة من البيانات) استنادًا إلى **XChaCha20-Poly1305**.
    *   **التشفير غير المتماثل:** يستخدم **X25519** (المبني على Curve2519) لآلية تغليف المفاتيح (KEM) لتغليف مفتاح الجلسة المتماثل، مما يضمن أن المستلم المقصود فقط يمكنه فك تشفيره.

*   **مجموعة أساسيات تشفير حديثة:**
    *   **اشتقاق المفاتيح:** يستخدم **Argon2id**، الفائز في مسابقة تجزئة كلمات المرور، لمقاومة محاولات الاختراق بواسطة وحدات معالجة الرسومات (GPU) والدوائر المتكاملة محددة التطبيقات (ASIC) بفعالية.
    *   **التوقيعات الرقمية:** يستفيد من **Ed25519** لتوفير قدرات توقيع رقمي عالية السرعة والأمان.
    *   **توحيد المفاتيح:** يستفيد بذكاء من ميزة إمكانية تحويل مفاتيح Ed25519 بأمان إلى مفاتيح X25519، مما يسمح لزوج مفاتيح رئيسي واحد بتلبية احتياجات التوقيع والتشفير معًا.

*   **دعم شامل للبنية التحتية للمفاتيح العامة (PKI):**
    *   **دورة حياة الشهادة:** يدعم إنشاء طلبات توقيع الشهادات (CSRs) المتوافقة مع معيار X.509 v3.
    *   **تحقق صارم من الشهادات:** يوفر عملية تحقق موحدة من الشهادات، تشمل سلسلة الثقة، فترة الصلاحية، ومطابقة الموضوع.
    *   **فحص إلزامي للإلغاء (OCSP):** يتميز بفحص صارم ومدمج لبروتوكول حالة الشهادة عبر الإنترنت (OCSP) مع سياسة "الإغلاق عند الفشل". إذا لم يمكن تأكيد صلاحية الشهادة، يتم إيقاف العملية فورًا.

*   **أمان ذاكرة صلب:**
    *   يعرض وظائف الذاكرة الآمنة لمكتبة `libsodium` من خلال واجهة برمجة التطبيقات العامة، مما يسمح للعملاء بالتعامل مع البيانات الحساسة (مثل مفاتيح الجلسة) بأمان.
    *   **[موثق أمنيًا]** يتم تخزين جميع المفاتيح الخاصة الداخلية **وغيرها من الأسرار الهامة (مثل بذور المفاتيح وقيم التجزئة الوسيطة)** في ذاكرة مقفلة، **مما يمنع نظام التشغيل من مبادلتها إلى القرص**، ويتم مسحها بأمان قبل تحريرها. تتم إدارة الحدود مع مكتبات الطرف الثالث (مثل OpenSSL) بعناية. عندما يجب أن تعبر البيانات الحساسة إلى مناطق الذاكرة القياسية (على سبيل المثال، عند تمرير بذرة إلى OpenSSL في `generate_csr`)، تستخدم هذه المكتبة تقنيات الدفاع في العمق (مثل مسح مخازن الذاكرة المؤقتة فورًا بعد الاستخدام) للتخفيف من المخاطر الكامنة، مما يمثل أفضل الممارسات عند التفاعل مع المكتبات التي لا تدرك أمان الذاكرة.

*   **ممارسات هندسية عالية الجودة:**
    *   **حدود واجهة برمجة تطبيقات واضحة:** يوفر ملف رأس عام واحد، `hsc_kernel.h`، الذي يغلف جميع تفاصيل التنفيذ الداخلية باستخدام مؤشرات مبهمة، مما يحقق تماسكًا عاليًا وترابطًا منخفضًا.
    *   **مجموعة اختبارات شاملة:** تتضمن مجموعة من اختبارات الوحدة والتكامل التي تغطي التشفير الأساسي، والبنية التحتية للمفاتيح العامة، ووظائف واجهة برمجة التطبيقات عالية المستوى لضمان صحة وموثوقية الكود.
    *   **نظام تسجيل منفصل:** ينفذ آلية تسجيل قائمة على رد النداء (callback)، مما يمنح التطبيق العميل تحكمًا كاملاً في كيفية ومكان عرض رسائل السجل، مما يجعل المكتبة مناسبة لأي بيئة.
    *   **وثائق وأمثلة شاملة:** يوفر ملف `README.md` مفصل، إلى جانب برنامج تجريبي جاهز للتشغيل وأداة سطر أوامر قوية.

## 3. هيكل المشروع

يستخدم المشروع هيكل أدلة نظيفًا ومتعدد الطبقات لتحقيق فصل الاهتمامات.

```.
├── include/
│   └── hsc_kernel.h      # [أساسي] ملف الرأس العام الوحيد لواجهة برمجة التطبيقات
├── src/                  # الكود المصدري
│   ├── common/           # وحدات داخلية مشتركة (ذاكرة آمنة، تسجيل)
│   ├── core_crypto/      # وحدات تشفير أساسية داخلية (أغلفة لـ libsodium)
│   ├── pki/              # وحدات PKI داخلية (أغلفة لـ OpenSSL, libcurl)
│   ├── hsc_kernel.c      # [أساسي] تنفيذ واجهة برمجة التطبيقات العامة
│   ├── main.c            # مثال على استخدام الواجهة: برنامج تجريبي شامل
│   └── cli.c             # مثال على استخدام الواجهة: أداة سطر أوامر قوية
├── tests/                # اختبارات الوحدة وأدوات الاختبار
│   ├── test_*.c          # اختبارات الوحدة لمختلف الوحدات
│   ├── test_api_integration.c # [جديد] اختبارات شاملة لواجهات برمجة التطبيقات عالية المستوى
│   ├── test_helpers.h/.c # وظائف مساعدة للاختبار (إنشاء CA، التوقيع)
│   └── test_ca_util.c    # الكود المصدري لأداة CA الاختبارية المستقلة
├── Makefile              # نص برمجي للبناء وإدارة المهام
└── README.md             # وثائق هذا المشروع
```

## 4. بداية سريعة

### 4.1 الاعتماديات

*   **أدوات البناء:** `make`
*   **مترجم C:** `gcc` أو `clang` (مع دعم C11 و `-Werror`)
*   **libsodium:** (`libsodium-dev`)
*   **OpenSSL:** يوصى بالإصدار **v3.0** أو أحدث (`libssl-dev`)
*   **libcurl:** (`libcurl4-openssl-dev`)

**التثبيت على الأنظمة الرئيسية:**

*   **Debian/Ubuntu:**
    ```bash
    sudo apt-get update
    sudo apt-get install build-essential libsodium-dev libssl-dev libcurl4-openssl-dev
    ```
*   **Fedora/RHEL/CentOS:**
    ```bash
    sudo dnf install gcc make libsodium-devel openssl-devel libcurl-devel
    ```
*   **macOS (باستخدام Homebrew):**
    ```bash
    brew install libsodium openssl@3 curl
    ```

### 4.2 الترجمة والاختبار

تم تصميم المشروع ليكون محمولًا للغاية ويتجنب المسارات المضمنة الخاصة بالمنصة، مما يضمن ترجمته وتشغيله بشكل صحيح على جميع الأنظمة المدعومة.

1.  **ترجمة جميع الأهداف (المكتبة، العرض التوضيحي، أداة سطر الأوامر، الاختبارات):**
    ```bash
    make all
    ```

2.  **تشغيل مجموعة الاختبارات الشاملة (خطوة حاسمة):**
    ```bash
    make run-tests
    ```
    > **ملاحظة هامة حول السلوك المتوقع لاختبار OCSP**
    >
    > إحدى حالات الاختبار في `test_pki_verification` تتحقق عمدًا من شهادة تشير إلى خادم OCSP محلي غير موجود (`http://127.0.0.1:8888`). سيفشل طلب الشبكة، وعند هذه النقطة **يجب** على الدالة `hsc_verify_user_certificate` أن تُرجع `-12` (رمز الخطأ لـ `HSC_ERROR_CERT_REVOKED_OR_OCSP_FAILED`). يؤكد برنامج الاختبار على قيمة الإرجاع المحددة هذه.
    >
    > هذا "الفشل" هو **السلوك المتوقع والصحيح**، لأنه يثبت تمامًا أن سياسة الأمان "الإغلاق عند الفشل" الخاصة بنا مطبقة بشكل صحيح: **إذا تعذر تأكيد حالة إلغاء الشهادة لأي سبب، فسيتم التعامل معها على أنها غير صالحة.**

3.  **تشغيل البرنامج التجريبي:**
    ```bash
    ./bin/hsc_demo
    ```

4.  **استكشاف أداة سطر الأوامر:**
    ```bash
    ./bin/hsc_cli
    ```

5.  **تنظيف ملفات البناء:**
    ```bash
    make clean
    ```

## 5. دليل الاستخدام

### 5.1 الاستخدام كأداة سطر أوامر (`hsc_cli` و `test_ca_util`)

يقدم هذا القسم سير عمل كامل ومستقل يوضح كيف يمكن لمستخدمين، أليس وبوب، إجراء تبادل آمن للملفات باستخدام أدوات سطر الأوامر المتوفرة.

**أدوار الأدوات:**
*   `./bin/test_ca_util`: أداة مساعدة تحاكي سلطة تصديق (CA)، مسؤولة عن إنشاء شهادة جذر وتوقيع شهادات المستخدمين.
*   `./bin/hsc_cli`: أداة العميل الأساسية لإنشاء المفاتيح، وإنشاء CSR، والتحقق من الشهادات، وتشفير/فك تشفير الملفات.

**مثال على سير عمل كامل: أليس تشفر ملفًا وترسله بأمان إلى بوب**

1.  **(إعداد) إنشاء سلطة تصديق اختبارية (CA):**
    *نستخدم `test_ca_util` لإنشاء مفتاح CA جذر وشهادة موقعة ذاتيًا.*
    ```bash
    ./bin/test_ca_util gen-ca ca.key ca.pem
    ```

2.  **(أليس وبوب) إنشاء أزواج المفاتيح الرئيسية الخاصة بهما:**
    ```bash
    ./bin/hsc_cli gen-keypair alice
    ./bin/hsc_cli gen-keypair bob
    ```
    *ينشئ هذا `alice.key`، `alice.pub`، `bob.key`، و `bob.pub`.*

3.  **(أليس وبوب) إنشاء طلبات توقيع الشهادات (CSRs):**
    ```bash
    ./bin/hsc_cli gen-csr alice.key "alice@example.com"
    ./bin/hsc_cli gen-csr bob.key "bob@example.com"
    ```
    *ينشئ هذا `alice.csr` و `bob.csr`.*

4.  **(CA) توقيع طلبات CSR لإصدار الشهادات:**
    *تستخدم CA مفتاحها الخاص (`ca.key`) وشهادتها (`ca.pem`) لتوقيع طلبات CSR.*
    ```bash
    ./bin/test_ca_util sign alice.csr ca.key ca.pem alice.pem
    ./bin/test_ca_util sign bob.csr ca.key ca.pem bob.pem
    ```
    *الآن يمتلك أليس وبوب شهاداتهما الرسمية، `alice.pem` و `bob.pem`.*

5.  **(أليس) التحقق من شهادة بوب قبل الإرسال:**
    *تستخدم أليس شهادة CA الموثوقة (`ca.pem`) للتحقق من هوية بوب. هذه خطوة حاسمة قبل الثقة بشهادته.*
    ```bash
    ./bin/hsc_cli verify-cert bob.pem --ca ca.pem --user "bob@example.com"
    ```

6.  **(أليس) تشفير ملف لبوب:**
    *لدى أليس الآن عدة خيارات:*

    **الخيار أ: مستند إلى الشهادة مع التحقق (الخيار الآمن الافتراضي والموصى به)**
    > هذه هي الطريقة القياسية والآمنة للعمل. **تتطلب** الأداة من أليس توفير شهادة CA واسم المستخدم المتوقع لإجراء تحقق كامل وصارم من شهادة بوب قبل التشفير.
    ```bash
    echo "This is top secret information." > secret.txt
    ./bin/hsc_cli encrypt secret.txt --to bob.pem --from alice.key --ca ca.pem --user "bob@example.com"
    ```

    **الخيار ب: مستند إلى الشهادة بدون تحقق (خطير - للاستخدام المتقدم فقط)**
    > إذا كانت أليس متأكدة تمامًا من صحة الشهادة وترغب في تخطي التحقق، يجب عليها استخدام علامة `--no-verify` بشكل صريح. **لا يوصى بهذا.**
    ```bash
    # استخدم بحذر شديد!
    ./bin/hsc_cli encrypt secret.txt --to bob.pem --from alice.key --no-verify
    ```

    **الخيار ج: وضع المفتاح المباشر (متقدم - للمفاتيح الموثوقة مسبقًا)**
    *إذا كانت أليس قد حصلت بالفعل على مفتاح بوب العام (`bob.pub`) من خلال قناة آمنة وموثوقة، فيمكنها التشفير إليه مباشرة، متجاوزة كل منطق الشهادات.*
    ```bash
    ./bin/hsc_cli encrypt secret.txt --recipient-pk-file bob.pub --from alice.key
    ```
    *تنشئ جميع الخيارات `secret.txt.hsc`. يمكن لأليس الآن إرسال `secret.txt.hsc` وشهادتها `alice.pem` إلى بوب.*

7.  **(بوب) فك تشفير الملف عند الاستلام:**
    *يستخدم بوب مفتاحه الخاص (`bob.key`) لفك تشفير الملف. اعتمادًا على كيفية تشفير أليس له، سيحتاج إما إلى شهادتها (`alice.pem`) أو مفتاحها العام الخام (`alice.pub`).*

    **إذا استخدمت أليس الخيار أ أو ب (شهادة):**
    ```bash
    ./bin/hsc_cli decrypt secret.txt.hsc --to bob.key --from alice.pem
    ```

    **إذا استخدمت أليس الخيار ج (مفتاح مباشر):**
    ```bash
    ./bin/hsc_cli decrypt secret.txt.hsc --to bob.key --sender-pk-file alice.pub
    ```
    *سينتج كلا الأمرين `secret.txt.decrypted`.*
    ```bash
    cat secret.txt.decrypted
    ```

### 5.2 الاستخدام كمكتبة في مشروعك

يعتبر `src/main.c` مثالًا ممتازًا على التكامل. يكون تدفق استدعاء واجهة برمجة التطبيقات النموذجي كما يلي:

1.  **التهيئة العامة وإعداد السجل:** استدعاء `hsc_init()` عند بدء التشغيل وتسجيل رد نداء (callback) للسجل.
    ```c
    #include "hsc_kernel.h"
    #include <stdio.h>

    // تعريف دالة تسجيل بسيطة لتطبيقك
    void my_app_logger(int level, const char* message) {
        // مثال: طباعة الأخطاء إلى stderr، والمعلومات إلى stdout
        if (level >= 2) { // 2 = ERROR
            fprintf(stderr, "[HSC_LIB_ERROR] %s\n", message);
        } else {
            printf("[HSC_LIB_INFO] %s\n", message);
        }
    }

    int main() {
        if (hsc_init() != HSC_OK) {
            // معالجة الخطأ الفادح
        }
        // تسجيل دالة التسجيل الخاصة بك مع المكتبة
        hsc_set_log_callback(my_app_logger);

        // ... الكود الخاص بك ...
        hsc_cleanup();
        return 0;
    }
    ```

2.  **المرسل (أليس) يشفر البيانات:**
    ```c
    // 1. إنشاء مفتاح جلسة لمرة واحدة
    unsigned char session_key[HSC_SESSION_KEY_BYTES];
    hsc_random_bytes(session_key, sizeof(session_key));

    // 2. تشفير البيانات بمفتاح الجلسة باستخدام AEAD (للبيانات الصغيرة)
    const char* message = "Secret message";
    // ... (منطق التشفير هو نفسه كما في المثال) ...

    // 3. التحقق من شهادة المستلم (بوب)
    if (hsc_verify_user_certificate(bob_cert_pem, ca_pem, "bob@example.com") != HSC_OK) {
        // الشهادة غير صالحة، قم بالإلغاء! ستقوم المكتبة بتسجيل التفاصيل عبر رد النداء الخاص بك.
    }

    // 4. استخراج مفتاح بوب العام من شهادته
    unsigned char bob_pk[HSC_MASTER_PUBLIC_KEY_BYTES];
    if (hsc_extract_public_key_from_cert(bob_cert_pem, bob_pk) != HSC_OK) {
        // معالجة خطأ الاستخراج
    }

    // 5. تغليف مفتاح الجلسة
    // ... (منطق التغليف هو نفسه كما في المثال) ...
    ```

3.  **المستقبل (بوب) يفك تشفير البيانات:**
    *يظل منطق فك التشفير كما هو، ولكن سيتم الآن الإبلاغ عن أي أخطاء داخلية أثناء فك التغليف أو فك تشفير AEAD من خلال رد النداء `my_app_logger` المسجل بدلاً من تلويث `stderr` مباشرة.*

## 6. نظرة عميقة: الهيكلية التقنية

جوهر هذا المشروع هو نموذج تشفير هجين يجمع بين مزايا التشفير غير المتماثل والمتماثل لتحقيق نقل بيانات آمن وفعال.

**مخطط تدفق البيانات وعلاقة المفاتيح:**

```
المرسل (أليس)                                           المستقبل (بوب)
========================================================================
[ نص عادي ] ------> إنشاء [ مفتاح جلسة ]
                      |          |
(تشفير متماثل) <-----'          '-> (تغليف غير متماثل) باستخدام: مفتاح بوب العام، مفتاح أليس الخاص
     |                                          |
[ بيانات مشفرة ]                    [ مفتاح جلسة مغلف ]
     |                                          |
     '--------------------.  .------------------'
                          |  |
                          v  v
                     [ حزمة بيانات ]
                          |
   ==================>  عبر الشبكة/ملف  =================>
                          |
                     [ حزمة بيانات ]
                          |  |
           .--------------'  '----------------.
           |                                  |
[ مفتاح جلسة مغلف ]                 [ بيانات مشفرة ]
           |                                  |
           v                                  |
(فك تغليف غير متماثل) باستخدام: مفتاح بوب الخاص، مفتاح أليس العام
           |                                  |
           v                                  |
      [ مفتاح جلسة مستعاد ] <--------$----' (فك تشفير متماثل)
           |
           v
      [ نص عادي ]
```

## 7. التكوين المتقدم: تعزيز الأمان باستخدام متغيرات البيئة

للتكيف مع متطلبات الأجهزة والأمان المستقبلية دون تعديل الكود، يدعم هذا المشروع **زيادة** التكلفة الحسابية لدالة اشتقاق المفاتيح (Argon2id) عبر متغيرات البيئة.

*   **`HSC_ARGON2_OPSLIMIT`**: يضبط عدد العمليات (جولات الحساب) لـ Argon2id.
*   **`HSC_ARGON2_MEMLIMIT`**: يضبط استخدام الذاكرة بالبايت لـ Argon2id.

**ملاحظة أمان هامة:** يمكن استخدام هذه الميزة **فقط لتعزيز معايير الأمان**. إذا كانت القيم المعينة في متغيرات البيئة أقل من الحد الأدنى لمعايير الأمان المضمنة في المشروع، فسيتجاهل البرنامج تلقائيًا القيم غير الآمنة ويفرض الحدود الدنيا المضمنة.

**مثال على الاستخدام:**

```bash
# مثال: زيادة حد العمليات إلى 10 وحد الذاكرة إلى 512 ميغابايت.
# ملاحظة: يتطلب HSC_ARGON2_MEMLIMIT القيمة بالبايت.
# 512 * 1024 * 1024 = 536870912 بايت.
export HSC_ARGON2_OPSLIMIT=10
export HSC_ARGON2_MEMLIMIT=536870912

# أي برنامج يتم تشغيله في shell مع تعيين هذه المتغيرات سيستخدم تلقائيًا هذه المعلمات الأقوى.
./bin/hsc_cli gen-keypair my_strong_key
```

## 8. موضوع متقدم: مقارنة أوضاع التشفير

يوفر Oracipher Core مساري عمل مختلفين للتشفير الهجين، لكل منهما ضمانات أمان مختلفة. اختيار المسار الصحيح أمر بالغ الأهمية.

### مسار العمل القائم على الشهادات (الافتراضي والموصى به)

*   **كيف يعمل:** يستخدم شهادات X.509 لربط هوية المستخدم (على سبيل المثال، `bob@example.com`) بمفتاحه العام.
*   **ضمانات الأمان:**
    *   **المصادقة:** يتحقق بشكل تشفيري من أن المفتاح العام ينتمي بالفعل إلى المستلم المقصود.
    *   **النزاهة:** يضمن عدم العبث بالشهادة.
    *   **فحص الإلغاء:** يتحقق بنشاط عبر OCSP مما إذا كانت الشهادة قد تم إلغاؤها من قبل السلطة المصدرة.
*   **متى يُستخدم:** في أي سيناريو لا يمتلك فيه المرسل والمستقبل قناة موجودة مسبقًا وآمنة للغاية لتبادل المفاتيح العامة. هذا هو المعيار لمعظم الاتصالات القائمة على الإنترنت.

### مسار العمل بالمفتاح المباشر (الخام) (متقدم)

*   **كيف يعمل:** يتجاوز كل منطق البنية التحتية للمفاتيح العامة والشهادات، ويقوم بالتشفير مباشرة إلى ملف مفتاح عام خام.
*   **ضمانات الأمان:**
    *   يوفر نفس مستوى **السرية** و **النزاهة** للبيانات المشفرة نفسها كما في وضع الشهادة.
*   **المقايضات الأمنية:**
    *   **لا يوجد مصادقة:** هذا الوضع **لا** يتحقق من هوية مالك المفتاح. يكون المستخدم مسؤولاً وحده عن ضمان صحة المفتاح العام الذي يستخدمه. سيؤدي استخدام مفتاح عام غير صحيح أو ضار إلى تشفير البيانات للطرف الخطأ.
*   **متى يُستخدم:** فقط في الأنظمة المغلقة أو البروتوكولات المحددة حيث تم تبادل المفاتيح العامة والتحقق منها من خلال آلية مستقلة وموثوقة خارج النطاق (على سبيل المثال، المفاتيح مدمجة في البرامج الثابتة لجهاز آمن، أو تم التحقق منها شخصيًا).

## 9. مرجع واجهة برمجة التطبيقات الأساسية (`include/hsc_kernel.h`)

### التهيئة والتنظيف
| الدالة | الوصف |
| :--- | :--- |
| `int hsc_init()` | **(يجب استدعاؤها أولاً)** تهيئة المكتبة بأكملها. |
| `void hsc_cleanup()` | استدعاؤها قبل خروج البرنامج لتحرير الموارد العامة. |

### إدارة المفاتيح
| الدالة | الوصف |
| :--- | :--- |
| `hsc_master_key_pair* hsc_generate_master_key_pair()` | إنشاء زوج مفاتيح رئيسي جديد. |
| `hsc_master_key_pair* hsc_load_master_key_pair_from_private_key(...)` | تحميل مفتاح خاص من ملف. |
| `int hsc_save_master_key_pair(...)` | حفظ زوج مفاتيح في ملفات. |
| `void hsc_free_master_key_pair(hsc_master_key_pair** kp)` | تحرير زوج مفاتيح رئيسي بأمان. |
| `int hsc_get_master_public_key(const hsc_master_key_pair* kp, ...)` | **[جديد]** استخراج المفتاح العام الخام من مقبض زوج المفاتيح. |

### البنية التحتية للمفاتيح العامة والشهادات
| الدالة | الوصف |
| :--- | :--- |
| `int hsc_generate_csr(...)` | إنشاء طلب توقيع شهادة (CSR) بتنسيق PEM. |
| `int hsc_verify_user_certificate(...)` | **(أساسي)** إجراء تحقق كامل من الشهادة (سلسلة الثقة، الصلاحية، الموضوع، OCSP). |
| `int hsc_extract_public_key_from_cert(...)` | استخراج مفتاح عام من شهادة تم التحقق منها. |

### تغليف المفاتيح (غير متماثل)
| الدالة | الوصف |
| :--- | :--- |
| `int hsc_encapsulate_session_key(...)` | تشفير مفتاح جلسة باستخدام المفتاح العام للمستلم. |
| `int hsc_decapsulate_session_key(...)` | فك تشفير مفتاح جلسة باستخدام المفتاح الخاص للمستلم. |

### تشفير الدفق (متماثل، للملفات الكبيرة)
| الدالة | الوصف |
| :--- | :--- |
| `hsc_crypto_stream_state* hsc_crypto_stream_state_new_push(...)` | إنشاء كائن حالة دفق التشفير. |
| `hsc_crypto_stream_state* hsc_crypto_stream_state_new_pull(...)` | إنشاء كائن حالة دفق فك التشفير. |
| `int hsc_crypto_stream_push(...)` | تشفير جزء من البيانات في دفق. |
| `int hsc_crypto_stream_pull(...)` | فك تشفير جزء من البيانات في دفق. |
| `void hsc_crypto_stream_state_free(hsc_crypto_stream_state** state)` | تحرير كائن حالة الدفق. |
| `int hsc_hybrid_encrypt_stream_raw(...)` | إجراء تشفير هجين كامل على ملف باستخدام مفتاح عام خام. |
| `int hsc_hybrid_decrypt_stream_raw(...)` | إجراء فك تشفير هجين كامل على ملف باستخدام مفتاح عام خام. |

### تشفير البيانات (متماثل، للبيانات الصغيرة)
| الدالة | الوصف |
| :--- | :--- |
| `int hsc_aead_encrypt(...)` | إجراء تشفير مصادق عليه على **جزء صغير من البيانات** باستخدام AEAD. |
| `int hsc_aead_decrypt(...)` | فك تشفير والتحقق من البيانات المشفرة بواسطة `hsc_aead_encrypt`. |

### الذاكرة الآمنة
| الدالة | الوصف |
| :--- | :--- |
| `void* hsc_secure_alloc(size_t size)` | تخصيص كتلة ذاكرة محمية وغير قابلة للمبادلة. |
| `void hsc_secure_free(void* ptr)` | مسح وتحرير كتلة ذاكرة محمية بأمان. |

### التسجيل
| الدالة | الوصف |
| :--- | :--- |
| `void hsc_set_log_callback(hsc_log_callback callback)` | **[جديد]** تسجيل دالة رد نداء (callback) للتعامل مع جميع سجلات المكتبة الداخلية. |

## 10. المساهمة

نرحب بجميع أشكال المساهمة! إذا وجدت خطأً، أو كان لديك اقتراح لميزة، أو ترغب في تحسين الوثائق، فلا تتردد في إرسال طلب سحب (Pull Request) أو إنشاء قضية (Issue).

## 11. ملاحظات حول الشهادات

يستخدم هذا المشروع نظام شهادات **X.509 v3** لربط المفاتيح العامة بهويات المستخدمين (على سبيل المثال، `alice@example.com`)، وبالتالي بناء الثقة. تتضمن عملية التحقق من الشهادة **التحقق من سلسلة التوقيع**، **فحص فترة الصلاحية**، **التحقق من هوية الموضوع**، و **فحص حالة الإلغاء (OCSP)**، كل ذلك تحت سياسة "الإغلاق عند الفشل" الصارمة.

## 12. الترخيص - نموذج الترخيص المزدوج

يتم توزيع هذا المشروع بموجب نموذج **ترخيص مزدوج**:

### 1. رخصة GNU Affero العامة v3.0 (AGPLv3)
هذه الرخصة مناسبة للمشاريع مفتوحة المصدر، والبحث الأكاديمي، والدراسة الشخصية. تتطلب أن أي أعمال مشتقة، سواء تم تعديلها أو تقديمها كخدمة عبر الشبكة، يجب أن يكون كودها المصدري الكامل متاحًا أيضًا بموجب AGPLv3.

### 2. ترخيص تجاري
يجب الحصول على ترخيص تجاري لأي تطبيقات أو منتجات أو خدمات تجارية مغلقة المصدر. إذا كنت لا ترغب في الالتزام بشروط المصدر المفتوح لـ AGPLv3، فيجب عليك الحصول على ترخيص تجاري.

**للحصول على ترخيص تجاري، يرجى الاتصال بـ: `eldric520lol@gmail.com`**

</div>