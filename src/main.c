/* src/main.c */

// Copyright 2025 Oracipher Core. All Rights Reserved.
//
// Main demonstration program for the Oracipher Core v5.1 library.
// This file demonstrates the end-to-end workflow of an Authenticated
// Ephemeral KEM, including key generation, certificate loading,
// file encryption (AEAD), and secure sharing.

#include <errno.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "hsc_kernel.h"
// Include sodium.h for secure memory comparison (sodium_memcmp).
#include <sodium.h>

// --- Helper Functions ---

// Prints binary data in hexadecimal format to stdout.
//
// Args:
//   label: A descriptive label printed before the hex string.
//   data: Pointer to the binary data.
//   len: Length of the data in bytes.
void print_hex(const char* label, const unsigned char* data, size_t len) {
    printf("%s: ", label);
    for (size_t i = 0; i < len; ++i) {
        printf("%02x", data[i]);
    }
    printf("\n");
}

// Reads the content of a PEM file into a null-terminated string.
//
// Performs safety checks including binary mode opening and file size
// limitations to prevent denial-of-service attacks or overflows.
//
// Args:
//   filename: The path to the file to read.
//
// Returns:
//   A pointer to the malloc'd buffer containing the file content,
//   or NULL if an error occurred. The caller is responsible for freeing memory.
char* read_pem_file(const char* filename) {
    FILE* f = fopen(filename, "rb");
    if (!f) {
        fprintf(stderr, "\nError: Cannot open required PEM file '%s'.\n", filename);
        fprintf(stderr, "Please ensure you have generated all required certificates "
                        "using the 'test_ca_util' tool as described in the README.\n");
        return NULL;
    }

    fseek(f, 0, SEEK_END);
    long long length = 0;
#ifdef _WIN32
    length = _ftelli64(f);
#else
    length = ftell(f);
#endif

    fseek(f, 0, SEEK_SET);

    // Limit maximum read size to 1MB to prevent DoS attacks and verify file validity.
    if (length <= 0 || length > 1024 * 1024) {
        fprintf(stderr, "Error: File size is invalid or too large (DoS protection limit).\n");
        fclose(f);
        return NULL;
    }

    char* buffer = malloc((size_t)length + 1);
    if (!buffer) {
        fclose(f);
        return NULL;
    }

    if (fread(buffer, 1, (size_t)length, f) != (size_t)length) {
        fclose(f);
        free(buffer);
        return NULL;
    }
    buffer[length] = '\0';
    fclose(f);
    return buffer;
}

// --- Main Demonstration Program ---

int main() {
    // Updated banner to reflect "Sender-PFS" instead of generic "PFS"
    printf("--- Oracipher Core v5.1 (Auth+Sender-PFS) Kernel API Demo ---\n");
    printf("This program demonstrates the end-to-end workflow as a library client "
           "(Authenticated Ephemeral KEM).\n");
    printf("Security Note: This protocol provides Sender Compromise Resistance.\n");
    printf("It assumes CA certificates and user certificates have been generated "
           "by an independent CA tool.\n\n");

    int ret = 1;

    // --- Resource Declaration ---
    // Declare all resources that require cleanup at the end of the scope.
    hsc_master_key_pair* alice_mkp = NULL;
    char* ca_cert_pem = NULL;
    char* alice_cert_pem = NULL;
    unsigned char* encrypted_file = NULL;
    unsigned char* encapsulated_session_key = NULL;
    unsigned char* decrypted_session_key = NULL;
    unsigned char* decrypted_file_content = NULL;

    // --- Initialization ---
    // Pass NULL, NULL to use default security configuration and ENV Pepper.
    if (hsc_init(NULL, NULL) != HSC_OK) {
        fprintf(stderr, "Error: High Security Kernel Library initialization failed!\n");
        goto cleanup;
    }
    printf("Cryptography library initialized successfully.\n\n");

    // --- Stage 1: 'Alice' creates local key pair ---
    printf("--- Stage 1: 'Alice' creates her master key pair ---\n");
    const char* alice_username = "alice@example.com";

    alice_mkp = hsc_generate_master_key_pair();
    if (alice_mkp == NULL) {
        fprintf(stderr, "Error: Failed to generate Alice's master key pair.\n");
        goto cleanup;
    }
    printf("'Alice' master key pair generated in memory.\n\n");

    // --- Stage 2: Load certificates generated by external CA tool ---
    printf("--- Stage 2: Loading certificate files issued by external CA ---\n");
    ca_cert_pem = read_pem_file("ca.pem");
    alice_cert_pem = read_pem_file("alice.pem");
    if (!ca_cert_pem || !alice_cert_pem) {
        goto cleanup; // Error message already printed by read_pem_file
    }
    printf("Successfully loaded 'ca.pem' and 'alice.pem'.\n\n");

    // --- Stage 3: End-to-End File Encryption & Secure Sharing (Alice -> Alice) ---
    printf("--- Stage 3: End-to-End Sharing Demo (Alice -> Alice) ---\n");

    // 1. Local Encryption (Generate session key, encrypt file content with AEAD).
    printf("1. Local file encryption...\n");
    unsigned char session_key[HSC_SESSION_KEY_BYTES];
    hsc_random_bytes(session_key, sizeof(session_key));
    print_hex("  > [Plaintext] Session Key", session_key, sizeof(session_key));

    const char* file_content = "This is the secret content of the file.";
    printf("  > [Plaintext] File Content: \"%s\"\n", file_content);

    size_t file_content_len = strlen(file_content);
    size_t enc_file_buf_len = file_content_len + HSC_AEAD_OVERHEAD_BYTES;

    encrypted_file = hsc_secure_alloc(enc_file_buf_len);
    if (!encrypted_file) {
        fprintf(stderr, "Secure memory allocation failed!\n");
        goto cleanup;
    }
    unsigned long long actual_enc_file_len;

    // Updated API call with ciphertext_max_len
    if (hsc_aead_encrypt(encrypted_file, enc_file_buf_len, 
                         &actual_enc_file_len,
                         (unsigned char*)file_content, file_content_len,
                         session_key) != HSC_OK) {
        fprintf(stderr, "Critical Error: Symmetric file encryption failed!\n");
        goto cleanup;
    }
    printf("  > File content encrypted using AEAD.\n\n");

    // 2. Verify Recipient ('Alice') Certificate.
    printf("2. Verifying recipient ('Alice') certificate...\n");
    if (hsc_verify_user_certificate(alice_cert_pem, ca_cert_pem, alice_username) != HSC_OK) {
        fprintf(stderr, "Critical Error: Recipient certificate verification failed! Aborting share.\n");
        goto cleanup;
    }
    printf("  > Recipient certificate verified successfully!\n\n");

    // 3. Extract Recipient Public Key (for encryption).
    printf("3. Extracting recipient public key from certificate...\n");
    unsigned char recipient_pk[HSC_MASTER_PUBLIC_KEY_BYTES];
    
    // Updated API call with public_key_max_len
    if (hsc_extract_public_key_from_cert(alice_cert_pem, recipient_pk, sizeof(recipient_pk)) != HSC_OK) {
        fprintf(stderr, "Critical Error: Failed to extract public key from certificate!\n");
        goto cleanup;
    }
    print_hex("  > Extracted Recipient Public Key", recipient_pk, sizeof(recipient_pk));
    printf("\n");

    // 4. Encapsulate Session Key (Authenticated Ephemeral KEM).
    printf("4. Encapsulating session key for recipient (Authenticated Ephemeral KEM)...\n");
    size_t encapsulated_key_buf_len = HSC_MAX_ENCAPSULATED_KEY_SIZE;

    encapsulated_session_key = hsc_secure_alloc(encapsulated_key_buf_len);
    if (!encapsulated_session_key) {
        fprintf(stderr, "Secure memory allocation failed!\n");
        goto cleanup;
    }

    size_t actual_encapsulated_len;

    // Pass sender_mkp (Alice) for signing to ensure authenticity.
    // Updated API call with encrypted_output_max_len
    if (hsc_encapsulate_session_key(encapsulated_session_key, encapsulated_key_buf_len,
                                    &actual_encapsulated_len,
                                    session_key, sizeof(session_key),
                                    recipient_pk,
                                    alice_mkp) != HSC_OK) {
        fprintf(stderr, "Critical Error: Session key encapsulation failed!\n");
        goto cleanup;
    }
    printf("  > Session key encapsulated (Ephemeral Key + Sender Signature).\n");
    printf("  > Note: This ensures Sender Compromise Resistance (Sender-PFS).\n\n");

    // --- Stage 4: Decrypt as Recipient ---
    printf("--- Stage 4: Decrypting file as recipient 'Alice' ---\n");

    // In a real scenario, the recipient needs to identify the sender and retrieve
    // their public key. Here, the sender is Alice herself, so we extract the key
    // from Alice's certificate to verify the signature.
    unsigned char sender_public_key[HSC_MASTER_PUBLIC_KEY_BYTES];
    // Updated API call with public_key_max_len
    if (hsc_extract_public_key_from_cert(alice_cert_pem, sender_public_key, sizeof(sender_public_key)) != HSC_OK) {
        fprintf(stderr, "Critical Error: Failed to retrieve sender public key!\n");
        goto cleanup;
    }

    // 1. Decapsulate Session Key.
    printf("1. Decapsulating session key (Verifying signature)...\n");
    decrypted_session_key = hsc_secure_alloc(sizeof(session_key));
    if (!decrypted_session_key) {
        fprintf(stderr, "Secure memory allocation failed!\n");
        goto cleanup;
    }

    // Pass sender_public_key for signature verification.
    // Updated API call with decrypted_output_max_len
    if (hsc_decapsulate_session_key(decrypted_session_key, sizeof(session_key),
                                    encapsulated_session_key, actual_encapsulated_len,
                                    alice_mkp,
                                    sender_public_key) != HSC_OK) {
        fprintf(stderr, "Decryption Error: Failed to decapsulate session key (Signature invalid?)!\n");
        goto cleanup;
    }
    print_hex("  > [Decrypted] Recovered Session Key", decrypted_session_key, sizeof(session_key));

    if (sodium_memcmp(session_key, decrypted_session_key, sizeof(session_key)) != 0) {
        fprintf(stderr, "Verification Failed: Recovered session key does not match original!\n");
        goto cleanup;
    }
    printf("  > Verification Successful: Recovered session key matches original.\n\n");

    // 2. Decrypt File Content using Recovered Session Key.
    printf("2. Decrypting file content using recovered session key...\n");

    decrypted_file_content = hsc_secure_alloc(file_content_len + 1);
    if (!decrypted_file_content) {
        fprintf(stderr, "Secure memory allocation failed!\n");
        goto cleanup;
    }
    unsigned long long actual_dec_file_len;

    // Updated API call with decrypted_message_max_len
    if (hsc_aead_decrypt(decrypted_file_content, file_content_len + 1,
                         &actual_dec_file_len,
                         encrypted_file, actual_enc_file_len,
                         decrypted_session_key) != HSC_OK) {
        fprintf(stderr, "Decryption Error: Failed to decrypt file content!\n");
        goto cleanup;
    }
    decrypted_file_content[actual_dec_file_len] = '\0';

    printf("  > [Decrypted] Recovered Content: \"%s\"\n", (char*)decrypted_file_content);

    if (actual_dec_file_len == file_content_len &&
        sodium_memcmp(file_content, decrypted_file_content, file_content_len) == 0) {
        printf("  > Verification Successful: Recovered content matches original.\n\n");
    } else {
        printf("  > Verification Failed: Recovered content does not match original!\n\n");
        goto cleanup;
    }

    ret = 0;
    printf("\033[32m--- Demo Completed Successfully ---\033[0m\n");

cleanup:
    printf("\n--- Cleaning up resources ---\n");
    free(ca_cert_pem);
    free(alice_cert_pem);
    hsc_free_master_key_pair(&alice_mkp);

    if (encrypted_file) hsc_secure_free(encrypted_file);
    if (encapsulated_session_key) hsc_secure_free(encapsulated_session_key);
    if (decrypted_session_key) hsc_secure_free(decrypted_session_key);
    if (decrypted_file_content) hsc_secure_free(decrypted_file_content);

    hsc_cleanup();
    printf("Cleanup complete.\n");

    return ret;
}